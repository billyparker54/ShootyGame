<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>p5.js Game - Shooty Game (Load to Shop)</title>
    <style>
        body { padding: 0; margin: 0; display: flex; justify-content: center; align-items: center; flex-direction: column; background-color: #2c3e50; /* Darker background */ font-family: 'Arial', sans-serif; /* Cleaner font */}
        canvas { margin-top: 20px; border: 2px solid #34495e; /* Border matching background */}
        h1 { margin-bottom: 5px; color: #ecf0f1; /* Light text color */ font-weight: bold; text-shadow: 1px 1px 2px #1a252f; /* Subtle text shadow */}
        .menu-button { /* Basic styling */ }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
    </head>
<body>

    <script>
        // --- Constants ---
        // Gameplay Constants
        const BASE_PLAYER_SPEED = 3.5;
        const BASE_BULLET_DAMAGE = 1;
        const BULLET_SPEED = 5;
        const SHOOT_COOLDOWN_MS = 300;
        const PLAYER_RADIUS = 15;
        const BULLET_RADIUS = 4;
        const PLAYER_MAX_LIVES = 3;
        const PLAYER_HIT_DURATION = 30;

        // Enemy Constants
        const BASE_ENEMY_RADIUS = 10;
        const BASE_ENEMY_HP = 1;
        const BASE_ENEMY_SPEED = 1.5;
        const BASE_ENEMY_SPAWN_RATE = 90;
        const ENEMY_COLOR = [255, 20, 20]; // Vibrant red
        const BASE_ENEMY_REWARD = 1;
        const ENEMY_HIT_DURATION = 10;

        // Blue Enemy Constants
        const BLUE_ENEMY_RADIUS = 12;
        const BASE_BLUE_ENEMY_HP = 3;
        const BASE_BLUE_ENEMY_SPEED = BASE_ENEMY_SPEED * 1.5;
        const BASE_BLUE_ENEMY_SPAWN_INTERVAL_SEC = 12;
        const BLUE_ENEMY_COLOR = [0, 100, 255];
        const BASE_BLUE_ENEMY_REWARD = 5;

        // Powerup Constants
        const POWERUP_COLOR = [128, 0, 128];
        const POWERUP_WIDTH = 15;
        const POWERUP_HEIGHT = 15;
        const POWERUP_SPAWN_INTERVAL_SEC = 7;
        const POWERUP_TYPE_HOMING = "homing";

        // Homing Bullet Constants
        const MAX_STEER_FORCE = 0.4;

        // Time Stop Constants
        const TIME_STOP_DURATION_SEC = 2.0;
        const TIME_STOP_CHANCE = 0.05;
        const TIME_STOP_CHECK_INTERVAL_MS = 1000;
        const TIME_STOP_KEY = 'e';

        // Control Constants
        const AUTO_FIRE_TOGGLE_KEY = 'q';
        const RETURN_TO_MENU_KEY = 'm';
        const NEXT_WAVE_KEY = ' ';

        // Admin Constants
        const ADMIN_CHEAT_CODE = "sigma";
        const ADMIN_PANEL_TOGGLE_KEY = 'p';

        // Wave Constants
        const WAVE_DURATION_SEC = 30;

        // Weapon Constants
        const WEAPON_STANDARD = 'standard';
        const WEAPON_BOUNCY = 'bouncy';
        const WEAPON_SHOTGUN = 'shotgun';
        const WEAPON_MACHINE_GUN = 'machine_gun';
        const BOUNCY_BULLET_BOUNCES = 3;
        const BOUNCY_BULLET_DAMAGE = 1;
        const BOUNCY_BULLET_COLOR = [0, 255, 0];
        const SHOTGUN_BULLET_COUNT = 3;
        const SHOTGUN_SPREAD_ANGLE = Math.PI / 9;
        const SHOTGUN_COOLDOWN_MS = 2000;
        const MACHINE_GUN_COOLDOWN_MS = SHOOT_COOLDOWN_MS / 2;
        const MACHINE_GUN_LAG_MS = 1500;

        // Shop/Upgrade Costs
        const BASE_SPEED_COST = 15;
        const COST_INCREASE_SPEED = 10;
        const BASE_AUTO_FIRE_COST = 75;
        const BASE_BOUNCY_GUN_COST = 40;
        const BASE_SHOTGUN_COST = 65;
        const BASE_MACHINE_GUN_COST = 100;
        const BASE_BUY_LIFE_COST = 40;

        // Difficulty Constants
        const DIFFICULTY_EASY = 'easy';
        const DIFFICULTY_HARD = 'hard';

        // Color Palette
        const PLAYER_COLOR = [0, 150, 255];
        const BRONZE_COLOR = [205, 127, 50];
        const BACKGROUND_COLOR = [220, 220, 220];
        const LASER_SIGHT_COLOR = [255, 0, 0];
        const BRONZE_HIGHLIGHT_COLOR = [255, 224, 150];
        const BULLET_OUTLINE_COLOR = [0, 0, 0];
        const COIN_COLOR = [255, 215, 0];
        const COIN_OUTLINE_COLOR = [184, 134, 11];
        const GAME_OVER_BG_COLOR = [30, 30, 40, 250]; // Darker, more opaque
        const GAME_OVER_TITLE_COLOR = [231, 76, 60];
        const GAME_OVER_TEXT_COLOR = [236, 240, 241];
        const HIT_FLASH_COLOR = [255, 255, 255];

        // Text Colors & Sizes
        const SCORE_TEXT_COLOR = [0, 0, 0];
        const SCORE_TEXT_SIZE = 18;
        const INDICATOR_TEXT_COLOR = [255, 255, 255];
        const INDICATOR_TEXT_SIZE = 16;
        const LIVES_TEXT_COLOR = [255, 0, 0];

        // Shop UI Colors & Sizes
        const SHOP_BG_COLOR = [52, 73, 94, 245];
        const SHOP_TEXT_COLOR = [236, 240, 241];
        const SHOP_TITLE_TEXT_SIZE = 30;
        const SHOP_CATEGORY_HEADER_SIZE = 20;
        const SHOP_ITEM_TEXT_SIZE = 17;
        const SHOP_COST_TEXT_SIZE = 15;
        const SHOP_CARD_COLOR = [44, 62, 80, 220];
        const SHOP_CARD_STROKE = [30, 40, 50, 150];
        const GRAY_TEXT_COLOR = [149, 165, 166];

        // Shop Button Colors & Sizes
        const SHOP_BUTTON_WIDTH = 95;
        const SHOP_BUTTON_HEIGHT = 32;
        const SHOP_BUTTON_COLOR_ACTIVE = [46, 204, 113];
        const SHOP_BUTTON_COLOR_HOVER = [39, 174, 96];
        const SHOP_BUTTON_COLOR_INACTIVE = [127, 140, 141];
        const SHOP_BUTTON_TEXT_COLOR = [255, 255, 255];

        // Menu Colors
        const MENU_BG_COLOR = [44, 62, 80];
        const MENU_TITLE_COLOR = [236, 240, 241];
        const MENU_COIN_TEXT_COLOR = [241, 196, 15];
        const MENU_ADMIN_TEXT_COLOR = [231, 76, 60];

        // Menu Button Colors (Standardized for better look)
        const BUTTON_PRIMARY_COLOR = [52, 152, 219];    // Blue
        const BUTTON_PRIMARY_HOVER = [41, 128, 185];   // Darker Blue
        const BUTTON_DANGER_COLOR = [231, 76, 60];     // Red
        const BUTTON_DANGER_HOVER = [192, 57, 43];    // Darker Red
        const BUTTON_SUCCESS_COLOR = [46, 204, 113];   // Green
        const BUTTON_SUCCESS_HOVER = [39, 174, 96];  // Darker Green
        const BUTTON_SECONDARY_COLOR = [108, 122, 137]; // Greyish blue for neutral/secondary
        const BUTTON_SECONDARY_HOVER = [91, 102, 115];  // Darker Greyish blue
        const BUTTON_TEXT_COLOR = [255, 255, 255];


        // Particle Constants
        const EXPLOSION_PARTICLE_COUNT = 15;
        const EXPLOSION_PARTICLE_LIFESPAN = 30;
        const EXPLOSION_PARTICLE_SPEED = 2.5;
        const EXPLOSION_PARTICLE_SIZE_MIN = 2;
        const EXPLOSION_PARTICLE_SIZE_MAX = 5;

        // Admin Panel Colors & Layout
        const ADMIN_PANEL_BG_COLOR = [52, 73, 94, 240];
        const ADMIN_PANEL_TEXT_COLOR = [236, 240, 241];
        const ADMIN_PANEL_X_MARGIN = 50;
        const ADMIN_PANEL_Y_START = 80;
        const ADMIN_PANEL_LINE_HEIGHT = 28;
        const ADMIN_PANEL_VALUE_X_OFFSET = 250;

        // Confirmation Dialog Colors & Sizes
        const CONFIRM_BG_COLOR = [44, 62, 80, 220];
        const CONFIRM_BOX_COLOR = [52, 73, 94];
        const CONFIRM_TEXT_COLOR = [236, 240, 241];
        const CONFIRM_YES_COLOR = BUTTON_DANGER_COLOR; const CONFIRM_YES_HOVER = BUTTON_DANGER_HOVER;
        const CONFIRM_NO_COLOR = [127, 140, 141]; const CONFIRM_NO_HOVER = [149, 165, 166];
        const CONFIRM_BUTTON_WIDTH = 85;
        const CONFIRM_BUTTON_HEIGHT = 38;

        // Style Constants
        const BULLET_OUTLINE_WEIGHT = 1;
        const LASER_SIGHT_WEIGHT = 1.5;
        const COIN_ICON_RADIUS = 9;
        const SHOP_CARD_MARGIN = 15;
        const SHOP_CARD_PADDING = 12;
        const SHOP_HEADER_MARGIN_BOTTOM = 10;
        const SHOP_CATEGORY_MARGIN_TOP = 22;
        const SHOP_SCROLL_SPEED = 15;
        const BUTTON_CORNER_RADIUS = 6;

        // Shadow Constants
        const PANEL_SHADOW_COLOR = [0, 0, 0, 75];
        const BUTTON_SHADOW_COLOR = [0, 0, 0, 100];
        const TITLE_SHADOW_COLOR = [0, 0, 0, 100];
        const HUD_TEXT_SHADOW_COLOR = [0, 0, 0, 120];


        // Game State Constants
        const STATE_MENU = 0; const STATE_PLAYING = 1; const STATE_GAME_OVER = 2; const STATE_SHOP = 3;
        const STATE_CONFIRM_RESET = 4; const STATE_LOAD_OR_NEW = 5; const STATE_DIFFICULTY_SELECT = 6;

        // --- Global Variables ---
        let player = null; let bullets = []; let enemies = []; let powerups = []; let explosionParticles = [];
        let aimHistory = []; let current_state = STATE_MENU; let spawn_timer = 0;
        let last_blue_spawn_time_ms = 0; let last_powerup_spawn_time_ms = 0; let last_shot_time_ms = 0;
        let wave_timer_start_ms = 0; let time_stop_end_time_ms = 0; let last_timestop_chance_check_time_ms = 0;
        let player_lives = PLAYER_MAX_LIVES;
        let speed_level = parseInt(localStorage.getItem('shootyGameSpeedLevel') || '0', 10);
        let total_coins = parseInt(localStorage.getItem('shootyGameTotalCoins') || '0', 10);
        let auto_fire_purchased = localStorage.getItem('shootyGameAutoFirePurchased') === 'true';
        let bouncyGunPurchased = localStorage.getItem('shootyGameBouncyGunPurchased') === 'true';
        let shotgunPurchased = localStorage.getItem('shootyGameShotgunPurchased') === 'true';
        let machineGunPurchased = localStorage.getItem('shootyGameMachineGunPurchased') === 'true';
        let saved_wave = 1; let current_wave = 0; let current_run_score = 0;
        let current_player_speed; let current_bullet_damage = BASE_BULLET_DAMAGE;
        let current_enemy_spawn_rate; let current_blue_spawn_interval_sec;
        let current_difficulty = DIFFICULTY_EASY; let keys_pressed = new Set();
        let auto_aim_target = null; let auto_fire_active = auto_fire_purchased;
        let homing_shot_ready = false; let time_stop_ready = false; let time_stop_active = false;
        let wave_completed_flag = false; let playerIsHit = false; let playerHitTimer = 0;
        let currentWeaponType = WEAPON_STANDARD;

        // UI Element State
        let playButton = { x: 0, y: 0, w: 160, h: 55, isHovered: false };
        let resetButton = { x: 0, y: 0, w: 160, h: 45, isHovered: false };
        let loadGameButton = { x: 0, y: 0, w: 260, h: 55, isHovered: false };
        let newGameButton = { x: 0, y: 0, w: 260, h: 55, isHovered: false };
        let easyModeButton = { x: 0, y: 0, w: 220, h: 55, isHovered: false };
        let hardModeButton = { x: 0, y: 0, w: 220, h: 55, isHovered: false };
        let gameOverRestartButton = { x: 0, y: 0, w: 200, h: 50, isHovered: false };
        let gameOverMenuButton = { x: 0, y: 0, w: 200, h: 50, isHovered: false };

        let spdBuyButton = { x: 0, y: 0, w: SHOP_BUTTON_WIDTH, h: SHOP_BUTTON_HEIGHT, isHovered: false, isActive: false };
        let buyLifeButton = { x: 0, y: 0, w: SHOP_BUTTON_WIDTH, h: SHOP_BUTTON_HEIGHT, isHovered: false, isActive: false };
        let autoBuyButton = { x: 0, y: 0, w: SHOP_BUTTON_WIDTH, h: SHOP_BUTTON_HEIGHT, isHovered: false, isActive: false };
        let standardGunEquipButton = { x: 0, y: 0, w: SHOP_BUTTON_WIDTH, h: SHOP_BUTTON_HEIGHT, isHovered: false, isActive: false };
        let bouncyGunBuyButton = { x: 0, y: 0, w: SHOP_BUTTON_WIDTH, h: SHOP_BUTTON_HEIGHT, isHovered: false, isActive: false };
        let shotgunBuyButton = { x: 0, y: 0, w: SHOP_BUTTON_WIDTH, h: SHOP_BUTTON_HEIGHT, isHovered: false, isActive: false };
        let machineGunBuyButton = { x: 0, y: 0, w: SHOP_BUTTON_WIDTH, h: SHOP_BUTTON_HEIGHT, isHovered: false, isActive: false };
        let confirmYesButton = { x: 0, y: 0, w: CONFIRM_BUTTON_WIDTH, h: CONFIRM_BUTTON_HEIGHT, isHovered: false };
        let confirmNoButton = { x: 0, y: 0, w: CONFIRM_BUTTON_WIDTH, h: CONFIRM_BUTTON_HEIGHT, isHovered: false };

        let is_admin = false; let cheat_input_buffer = ""; let admin_panel_open = false;
        let menuSynth = null; let menuSequence = null; let coinSynth = null;
        let isAudioSetup = false;
        let shopScrollY = 0; let shopContentHeight = 0;
        let shopVisibleStartY = 80; // Adjusted after removing Gemini button
        let shopVisibleHeight = 0; let shopScrollableHeight = 0;


        // --- Shadow Helper Functions ---
        function applyShadow(offsetX, offsetY, blurRadius, shadowColorArray) {
            drawingContext.shadowOffsetX = offsetX;
            drawingContext.shadowOffsetY = offsetY;
            drawingContext.shadowBlur = blurRadius;
            let alpha = shadowColorArray.length > 3 ? shadowColorArray[3] / 255 : 0.5;
            drawingContext.shadowColor = `rgba(${shadowColorArray[0]}, ${shadowColorArray[1]}, ${shadowColorArray[2]}, ${alpha})`;
        }

        function clearShadow() {
            drawingContext.shadowOffsetX = 0;
            drawingContext.shadowOffsetY = 0;
            drawingContext.shadowBlur = 0;
            drawingContext.shadowColor = 'rgba(0,0,0,0)';
        }

        // --- Styled Button Drawing Function ---
        function drawStyledButton(x, y, w, h, label, options) {
            let currentFillColor;
            if (options.isActive === false) { // Explicitly check for false, as undefined means active
                currentFillColor = options.inactiveColor || [100, 100, 100];
            } else if (options.isHovered) {
                currentFillColor = options.hoverColor;
            } else {
                currentFillColor = options.baseColor;
            }

            if (options.shadowOptions) {
                applyShadow(options.shadowOptions.offsetX, options.shadowOptions.offsetY, options.shadowOptions.blurRadius, options.shadowOptions.color);
            }

            fill(currentFillColor);
            noStroke();
            rect(x, y, w, h, options.cornerRadius);

            if (options.shadowOptions) {
                clearShadow();
            }

            fill(options.textColor);
            let textSizeVal = options.textOptions && options.textOptions.size ? options.textOptions.size : h * 0.4;
            textSize(textSizeVal);
            textAlign(CENTER, options.textOptions && options.textOptions.vAlign ? options.textOptions.vAlign : CENTER);
            text(label, x + w / 2, y + h / 2 + ( (options.textOptions && options.textOptions.vAlign === TOP) ? textSizeVal*0.6 : (options.textOptions && options.textOptions.vAlign === BOTTOM ? -textSizeVal*0.1 : 0) ) );
        }


        // --- Particle Class (Adapted for Explosions) ---
        class ExplosionParticle {
            constructor(x, y, col) { this.pos = createVector(x, y); let angle = random(TWO_PI); let speed = random(EXPLOSION_PARTICLE_SPEED * 0.5, EXPLOSION_PARTICLE_SPEED); this.vel = createVector(cos(angle) * speed, sin(angle) * speed); this.acc = createVector(0, 0); this.lifespan = EXPLOSION_PARTICLE_LIFESPAN; this.color = col; this.size = random(EXPLOSION_PARTICLE_SIZE_MIN, EXPLOSION_PARTICLE_SIZE_MAX); }
            update() { this.vel.mult(0.95); this.pos.add(this.vel); this.lifespan -= 1; }
            display() { let alpha = map(this.lifespan, 0, EXPLOSION_PARTICLE_LIFESPAN, 0, 255); fill(this.color[0], this.color[1], this.color[2], alpha); noStroke(); ellipse(this.pos.x, this.pos.y, this.size); }
            isDead() { return this.lifespan <= 0; }
        }

        // --- Helper Functions ---
        function calculate_player_speed() { return BASE_PLAYER_SPEED * (1.0 + speed_level * 0.20); }
        function getShopMultiplier() { return (current_difficulty === DIFFICULTY_HARD) ? 2 : 1; }
        function getShopSpeedCost() { let base = BASE_SPEED_COST + speed_level * COST_INCREASE_SPEED; return base * getShopMultiplier(); }
        function getShopAutoFireCost() { return BASE_AUTO_FIRE_COST * getShopMultiplier(); }
        function getShopBouncyGunCost() { return BASE_BOUNCY_GUN_COST * getShopMultiplier(); }
        function getShopShotgunCost() { return BASE_SHOTGUN_COST * getShopMultiplier(); }
        function getShopMachineGunCost() { return BASE_MACHINE_GUN_COST * getShopMultiplier(); }
        function getShopBuyLifeCost() { return BASE_BUY_LIFE_COST * getShopMultiplier(); }

        current_player_speed = calculate_player_speed();
        function find_closest_enemy(playerX, playerY, enemy_list) { let closest_enemy = null; let min_dist_sq = Infinity; for (let enemy of enemy_list) { if (!enemy || typeof enemy.x === 'undefined' || typeof enemy.y === 'undefined' || enemy.hp <= 0) continue; let dx = enemy.x - playerX; let dy = enemy.y - playerY; let dist_sq = dx * dx + dy * dy; if (dist_sq < min_dist_sq) { min_dist_sq = dist_sq; closest_enemy = enemy; } } return closest_enemy; }
        function find_enemy_closest_by_angle(startX, startY, direction_vx, direction_vy, enemy_list) { if (!enemy_list || enemy_list.length === 0) return null; let shot_angle = atan2(direction_vy, direction_vx); let best_target = null; let min_angle_diff = Infinity; for (let enemy of enemy_list) { if (!enemy || typeof enemy.x === 'undefined' || typeof enemy.y === 'undefined') continue; let enemy_dx = enemy.x - startX; let enemy_dy = enemy.y - startY; let enemy_angle = atan2(enemy_dy, enemy_dx); let diff = shot_angle - enemy_angle; while (diff <= -PI) diff += TWO_PI; while (diff > PI) diff -= TWO_PI; let angle_diff = abs(diff); if (angle_diff < min_angle_diff) { min_angle_diff = angle_diff; best_target = enemy; } } return best_target; }
        function getLaggedAim(lagMs) {
            let targetTime = millis() - lagMs;
            let closestEntry = null;
            let smallestDiff = Infinity;
            for (let i = aimHistory.length - 1; i >= 0; i--) { let entry = aimHistory[i]; let diff = abs(entry.timestamp - targetTime); if (diff < smallestDiff) { smallestDiff = diff; closestEntry = entry; } else { break; } }
            if (closestEntry) { return { dx: closestEntry.aimX - closestEntry.playerX, dy: closestEntry.aimY - closestEntry.playerY }; } else { return null; }
        }


        // --- Classes ---
        class Player {
            constructor(x, y, radius, speed, col) {
                this.x = x; this.y = y; this.radius = radius; this.speed = speed; this.color = col;
            }
            update() {
                let e_spd = this.speed;
                if (keys_pressed.has('w') || keys_pressed.has(UP_ARROW)) { this.y -= e_spd; }
                if (keys_pressed.has('s') || keys_pressed.has(DOWN_ARROW)) { this.y += e_spd; }
                if (keys_pressed.has('a') || keys_pressed.has(LEFT_ARROW)) { this.x -= e_spd; }
                if (keys_pressed.has('d') || keys_pressed.has(RIGHT_ARROW)) { this.x += e_spd; }
                this.x = constrain(this.x, this.radius, width - this.radius);
                this.y = constrain(this.y, this.radius, height - this.radius);
            }
            display() {
                fill(this.color[0], this.color[1], this.color[2]);
                noStroke();
                ellipse(this.x, this.y, this.radius * 2);

                if (currentWeaponType === WEAPON_BOUNCY) {
                    push(); translate(this.x, this.y);
                    let final_aim_dx = mouseX - this.x; let final_aim_dy = mouseY - this.y;
                    if (current_state === STATE_PLAYING && !admin_panel_open) { if (auto_fire_active && auto_aim_target) { final_aim_dx = auto_aim_target.x - this.x; final_aim_dy = auto_aim_target.y - this.y; } }
                    let angle = atan2(final_aim_dy, final_aim_dx); rotate(angle);
                    const BouncyGun_BODY_COLOR = BOUNCY_BULLET_COLOR;
                    const BouncyGun_BARREL_COLOR = [100, 100, 100];
                    const BouncyGun_NOZZLE_COLOR = [70, 70, 70];
                    const BouncyGun_ACCENT_COLOR = [180, 255, 180];
                    let baseRadius = this.radius;
                    let gunBulgeLength = baseRadius * 0.8; let gunBulgeWidth = baseRadius * 0.9;
                    let gunBarrelLength = baseRadius * 1.3; let gunBarrelWidth = baseRadius * 0.45;
                    let gunNozzleRadius = baseRadius * 0.35; let gunAttachOffset = baseRadius * 0.1;
                    rectMode(CORNER); noStroke();
                    fill(BouncyGun_BODY_COLOR);
                    rect(gunAttachOffset, -gunBulgeWidth / 2, gunBulgeLength, gunBulgeWidth, baseRadius * 0.2);
                    fill(BouncyGun_ACCENT_COLOR); ellipseMode(CENTER);
                    ellipse(gunAttachOffset + gunBulgeLength * 0.5, 0, gunBulgeWidth * 0.55, gunBulgeWidth * 0.55);
                    fill(BouncyGun_BARREL_COLOR); rectMode(CORNER);
                    rect(gunAttachOffset + gunBulgeLength, -gunBarrelWidth / 2, gunBarrelLength, gunBarrelWidth, baseRadius * 0.1);
                    fill(BouncyGun_NOZZLE_COLOR); ellipseMode(CENTER);
                    ellipse(gunAttachOffset + gunBulgeLength + gunBarrelLength, 0, gunNozzleRadius * 2, gunNozzleRadius * 2);
                    pop();
                }
            }
        }

        class Bullet {
            constructor(x, y, vx, vy, radius, col) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.radius = radius; this.color = col; this.isDead = false; }
            update() { this.x += this.vx; this.y += this.vy; }
            display() { stroke(BULLET_OUTLINE_COLOR[0],BULLET_OUTLINE_COLOR[1],BULLET_OUTLINE_COLOR[2]); strokeWeight(BULLET_OUTLINE_WEIGHT); fill(this.color[0],this.color[1],this.color[2]); ellipse(this.x,this.y,this.radius*2); noStroke(); fill(BRONZE_HIGHLIGHT_COLOR[0],BRONZE_HIGHLIGHT_COLOR[1],BRONZE_HIGHLIGHT_COLOR[2]); let hs=this.radius; let ho=this.radius*0.35; ellipse(this.x-ho,this.y-ho,hs,hs); }
            is_offscreen() { return !(this.x>-this.radius && this.x<width+this.radius && this.y>-this.radius && this.y<height+this.radius); }
        }
        class HomingBullet extends Bullet { constructor(x, y, vx, vy, radius, col, initial_target) { super(x, y, vx, vy, radius, col); this.target = initial_target; this.steer_force = MAX_STEER_FORCE; } update() { try { if (this.target && (typeof this.target.hp==='undefined' || this.target.hp<=0 || typeof this.target.x==='undefined' || typeof this.target.y==='undefined')) {this.target=null;} if (this.target) { let ddx=this.target.x-this.x; let ddy=this.target.y-this.y; let dist=sqrt(ddx*ddx+ddy*ddy); if (dist>0) { ddx/=dist; ddy/=dist; let dvx=ddx*BULLET_SPEED; let dvy=ddy*BULLET_SPEED; let svx=dvx-this.vx; let svy=dvy-this.vy; let sms=svx*svx+svy*svy; if(sms > this.steer_force*this.steer_force && sms > 0){ let sc=this.steer_force/sqrt(sms); svx*=sc; svy*=sc; } this.vx+=svx; this.vy+=svy; let css=this.vx*this.vx+this.vy*this.vy; if(css>BULLET_SPEED*BULLET_SPEED && css>0){ let sc=BULLET_SPEED/sqrt(css); this.vx*=sc; this.vy*=sc;}}} super.update();} catch(e){console.error("HomingBullet Update Error:", e); this.target=null; super.update();} } }
        class BouncyBullet extends Bullet {
            constructor(x, y, vx, vy) { super(x, y, vx, vy, BULLET_RADIUS + 1, BOUNCY_BULLET_COLOR); this.bouncesLeft = BOUNCY_BULLET_BOUNCES; this.damage = BOUNCY_BULLET_DAMAGE; }
            update() { super.update(); let bouncedWall = false; if ((this.x < this.radius && this.vx < 0) || (this.x > width - this.radius && this.vx > 0)) { this.vx *= -1; bouncedWall = true; this.x = constrain(this.x, this.radius, width - this.radius); } if ((this.y < this.radius && this.vy < 0) || (this.y > height - this.radius && this.vy > 0)) { this.vy *= -1; bouncedWall = true; this.y = constrain(this.y, this.radius, height - this.radius); } if (bouncedWall) { this.bouncesLeft--; if (this.bouncesLeft <= 0) { this.isDead = true; } } }
            handleEnemyBounce() { this.bouncesLeft--; if (this.bouncesLeft <= 0) { this.isDead = true; } this.vx *= -1; this.vy *= -1; }
            display() { fill(this.color[0], this.color[1], this.color[2]); noStroke(); ellipse(this.x, this.y, this.radius * 2); }
        }
        class Enemy { constructor(x, y, radius, speed, hp, col, reward) { this.x=x; this.y=y; this.radius=radius; this.speed=speed; this.hp=hp; this.color=col; this.reward=reward; this.max_hp=hp; this.isHit = false; this.hitTimer = 0; } update(target_x, target_y) { if (this.isHit) { this.hitTimer--; if (this.hitTimer <= 0) { this.isHit = false; } } if(typeof target_x!=='number' || typeof target_y!=='number') return; let dx=target_x-this.x; let dy=target_y-this.y; let dist=sqrt(dx*dx+dy*dy); if (dist>0){let vx=(dx/dist)*this.speed; let vy=(dy/dist)*this.speed; this.x+=vx; this.y+=vy;}} display() { if (this.isHit) { fill(HIT_FLASH_COLOR); } else { fill(this.color[0], this.color[1], this.color[2]); } noStroke(); ellipse(this.x, this.y, this.radius * 2); } take_damage(damage_amount) { this.hp -= damage_amount; let destroyed = this.hp <= 0; if (!destroyed) { this.isHit = true; this.hitTimer = ENEMY_HIT_DURATION; } return destroyed; } }
        class PowerUp { constructor(x, y, w, h, color, type) { this.x=x; this.y=y; this.width=w; this.height=h; this.color=color; this.type=type; } display() { fill(this.color[0], this.color[1], this.color[2]); noStroke(); rect(this.x, this.y, this.width, this.height); } }

        // --- Spawning / Collision Helpers ---
        function spawn_enemy() { let edge=floor(random(4)); let sx=0, sy=0; let m=BASE_ENEMY_RADIUS+10; if(edge===0){sx=random(width); sy=-m;} else if(edge===1){sx=random(width); sy=height+m;} else if(edge===2){sx=-m; sy=random(height);} else {sx=width+m; sy=random(height);} let rwd=BASE_ENEMY_REWARD+floor(current_wave/5); let ne=new Enemy(sx,sy,BASE_ENEMY_RADIUS,BASE_ENEMY_SPEED,BASE_ENEMY_HP,ENEMY_COLOR,rwd); enemies.push(ne); }
        function spawn_blue_enemy() { let edge=floor(random(4)); let sx=0, sy=0; let m=BLUE_ENEMY_RADIUS+10; if(edge===0){sx=random(width); sy=-m;} else if(edge===1){sx=random(width); sy=height+m;} else if(edge===2){sx=-m; sy=random(height);} else {sx=width+m; sy=random(height);} let rwd=BASE_BLUE_ENEMY_REWARD+floor(current_wave/3); let ne=new Enemy(sx,sy,BLUE_ENEMY_RADIUS,BASE_BLUE_ENEMY_SPEED,BASE_BLUE_ENEMY_HP,BLUE_ENEMY_COLOR,rwd); enemies.push(ne); }
        function spawn_powerup() { if(powerups.length===0){ let px=random(width-POWERUP_WIDTH); let py=random(height-POWERUP_HEIGHT); let np=new PowerUp(px,py,POWERUP_WIDTH,POWERUP_HEIGHT,POWERUP_COLOR,POWERUP_TYPE_HOMING); powerups.push(np);} }
        function check_player_powerup_collision(p_obj, pu_list) { if (!p_obj) return; for(let i=pu_list.length-1; i>=0; i--){ if(!pu_list[i]) continue; let pu=pu_list[i]; let cx=constrain(p_obj.x,pu.x,pu.x+pu.width); let cy=constrain(p_obj.y,pu.y,pu.y+pu.height); let dSq=(p_obj.x-cx)**2+(p_obj.y-cy)**2; if(dSq < p_obj.radius**2){ if(pu.type===POWERUP_TYPE_HOMING){homing_shot_ready=true; console.log("Homing powerup collected!");} pu_list.splice(i,1); break;}} }

        // --- Game/Wave Start Function ---
        function start_new_game_or_wave(wave_number) {
            console.log(`Starting Wave ${wave_number} with difficulty ${current_difficulty}...`);
            current_wave = wave_number;
            current_enemy_spawn_rate = max(20, BASE_ENEMY_SPAWN_RATE - (current_wave - 1) * 4);
            current_blue_spawn_interval_sec = max(4, BASE_BLUE_ENEMY_SPAWN_INTERVAL_SEC - floor((current_wave - 1) / 2));
            current_player_speed = calculate_player_speed();
            auto_fire_active = auto_fire_purchased;
            player = new Player(width/2,height/2,PLAYER_RADIUS,current_player_speed,PLAYER_COLOR);
            bullets=[]; enemies=[]; powerups=[]; keys_pressed=new Set(); spawn_timer=0; auto_aim_target=null;
            wave_timer_start_ms=millis(); last_blue_spawn_time_ms=wave_timer_start_ms; last_powerup_spawn_time_ms=wave_timer_start_ms;
            homing_shot_ready=false; time_stop_ready=false; time_stop_active=false; time_stop_end_time_ms=0; last_timestop_chance_check_time_ms=wave_timer_start_ms;
            wave_completed_flag=false; playerIsHit = false; playerHitTimer = 0; explosionParticles = []; aimHistory = [];

             if(wave_number === 1){
                 current_run_score = 0; // Reset score for the new run
                 // Reload total_coins from localStorage or default to 0 for a completely new game session
                 total_coins = parseInt(localStorage.getItem('shootyGameTotalCoins') || '0', 10);
                 if (current_difficulty === DIFFICULTY_HARD) { player_lives = 1; }
                 else { player_lives = PLAYER_MAX_LIVES; }
             } else {
                 current_difficulty = DIFFICULTY_EASY; // Resuming a saved game defaults to easy
             }
             current_state=STATE_PLAYING;
         }

        // --- Function to Setup Tone.js Audio ---
        function setupMenuAudio() {
            if (isAudioSetup) return;
            try {
                menuSynth = new Tone.FMSynth({ harmonicity: 2, modulationIndex: 5, detune: 0, oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.5 }, modulation: { type: "square" }, modulationEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination();
                menuSynth.volume.value = -12;
                const melody = [ ["G#3", "8n"], null, "G3", "F3", "D#3", null, "D#3", null, ["G#3", "8n"], null, "G3", "F3", "D#3", null, "D#3", null, ["G#3", "8n"], null, "G3", "F3", "D#3", null, "D#3", null, ["G#3", "8n"], null, "G3", "F3", ["D#3", "4n"], null, null, null ];
                menuSequence = new Tone.Sequence((time, note) => { if (note) { menuSynth.triggerAttackRelease(note, "16n", time); } }, melody, "8n");
                menuSequence.loop = true;
                Tone.Transport.bpm.value = 128;

                coinSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                coinSynth.volume.value = -10;

                isAudioSetup = true;
                console.log("Menu and game audio setup complete.");
            } catch (e) { console.error("Error setting up Tone.js:", e); }
        }

        // --- p5.js Event Handlers ---
        function keyPressed() {
            let keyLower = key.toLowerCase();
            if (is_admin && admin_panel_open) {
                let statChanged = false;
                if (key === '2') { if (keyIsDown(SHIFT)) { if (speed_level > 0) speed_level--; statChanged = true; } else { speed_level++; statChanged = true; } }
                else if (key === '3') { auto_fire_purchased = !auto_fire_purchased; auto_fire_active = auto_fire_purchased; statChanged = true; }
                else if (key === '4') { total_coins += 1000; statChanged = true; }
                else if (key === '5') { if (keyIsDown(SHIFT)) { if (player_lives > 0) player_lives--; statChanged = true; } else { player_lives++; statChanged = true; } }
                else if (key === '6') { bouncyGunPurchased = !bouncyGunPurchased; statChanged = true; }
                else if (key === '7') { shotgunPurchased = !shotgunPurchased; statChanged = true; }
                else if (key === '8') { machineGunPurchased = !machineGunPurchased; statChanged = true; }
                else if (keyLower === ADMIN_PANEL_TOGGLE_KEY) { admin_panel_open = false; return false; }
                if (statChanged) {
                    current_player_speed = calculate_player_speed();
                    localStorage.setItem('shootyGameSpeedLevel', speed_level.toString());
                    localStorage.setItem('shootyGameTotalCoins', total_coins.toString());
                    localStorage.setItem('shootyGameAutoFirePurchased', auto_fire_purchased ? 'true' : 'false');
                    localStorage.setItem('shootyGameBouncyGunPurchased', bouncyGunPurchased ? 'true' : 'false');
                    localStorage.setItem('shootyGameShotgunPurchased', shotgunPurchased ? 'true' : 'false');
                    localStorage.setItem('shootyGameMachineGunPurchased', machineGunPurchased ? 'true' : 'false');
                } return false;
            }
            if (current_state === STATE_MENU && !is_admin) { if (keyLower.length === 1 && keyLower >= 'a' && keyLower <= 'z') { cheat_input_buffer += keyLower; if (cheat_input_buffer.length > ADMIN_CHEAT_CODE.length) { cheat_input_buffer = cheat_input_buffer.substring(cheat_input_buffer.length - ADMIN_CHEAT_CODE.length); } if (cheat_input_buffer === ADMIN_CHEAT_CODE) { is_admin = true; cheat_input_buffer = ""; } } else { cheat_input_buffer = ""; } }
            if (keyLower === ADMIN_PANEL_TOGGLE_KEY && is_admin) { admin_panel_open = !admin_panel_open; if (admin_panel_open) auto_aim_target = null; return false; }

            switch (current_state) {
                case STATE_SHOP: if (key === NEXT_WAVE_KEY && wave_completed_flag) { start_new_game_or_wave(current_wave + 1); shopScrollY = 0; return false; } if (key === NEXT_WAVE_KEY) return false; break;
                case STATE_GAME_OVER: if (key === ' ') { start_new_game_or_wave(1); return false; } else if (keyLower === RETURN_TO_MENU_KEY) { current_state = STATE_MENU; total_coins = parseInt(localStorage.getItem('shootyGameTotalCoins') || '0', 10); /* Reload coins for menu */ return false; } if (" m".includes(keyLower) || key === ' ') return false; break;
                case STATE_PLAYING: if (admin_panel_open) return false; if (keyLower === TIME_STOP_KEY && time_stop_ready && !time_stop_active) { time_stop_ready = false; time_stop_active = true; time_stop_end_time_ms = millis() + TIME_STOP_DURATION_SEC * 1000; return false; } else if (keyLower === AUTO_FIRE_TOGGLE_KEY && auto_fire_purchased) { auto_fire_active = !auto_fire_active; auto_aim_target = null; return false; } if (keyCode === UP_ARROW || keyCode === DOWN_ARROW || keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW) { keys_pressed.add(keyCode); } else { keys_pressed.add(keyLower); } if (key === ' ' || keyLower === TIME_STOP_KEY || keyLower === AUTO_FIRE_TOGGLE_KEY || keyCode === UP_ARROW || keyCode === DOWN_ARROW || keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW || 'wasd'.includes(keyLower)) { return false; } break;
            }
         }
        function keyReleased() { if (current_state === STATE_PLAYING) { let kl=key.toLowerCase(); if(keyCode===UP_ARROW||keyCode===DOWN_ARROW||keyCode===LEFT_ARROW||keyCode===RIGHT_ARROW){keys_pressed.delete(keyCode);}else{keys_pressed.delete(kl);}} }
        function mousePressed() {
            if (!isAudioSetup && typeof Tone !== 'undefined') {
                if (Tone.context.state !== 'running') {
                    Tone.start().then(() => {
                        setupMenuAudio();
                        if (current_state === STATE_MENU && menuSequence && Tone.Transport.state !== 'started') { Tone.Transport.start(); menuSequence.start(0); }
                    }).catch(e => console.error("Error starting Tone context:", e));
                } else { setupMenuAudio(); if (current_state === STATE_MENU && menuSequence && Tone.Transport.state !== 'started') { Tone.Transport.start(); menuSequence.start(0); } }
            }

            switch (current_state) {
                case STATE_PLAYING:
                    if (!auto_fire_active && player && !admin_panel_open && currentWeaponType !== WEAPON_MACHINE_GUN) {
                        let ctm = millis(); let cooldown = (currentWeaponType === WEAPON_SHOTGUN) ? SHOTGUN_COOLDOWN_MS : SHOOT_COOLDOWN_MS;
                        if (ctm - last_shot_time_ms >= cooldown) {
                            let aimDX = mouseX - player.x; let aimDY = mouseY - player.y; let dist = sqrt(aimDX * aimDX + aimDY * aimDY);
                            if (dist > 0) {
                                let baseAngle = atan2(aimDY, aimDX); let baseVX = (aimDX / dist) * BULLET_SPEED; let baseVY = (aimDY / dist) * BULLET_SPEED;
                                if (homing_shot_ready) { let te = find_enemy_closest_by_angle(player.x, player.y, baseVX, baseVY, enemies); bullets.push(new HomingBullet(player.x, player.y, baseVX, baseVY, BULLET_RADIUS, BRONZE_COLOR, te)); homing_shot_ready = false; }
                                else if (currentWeaponType === WEAPON_SHOTGUN) { for (let i = 0; i < SHOTGUN_BULLET_COUNT; i++) { let angleOffset = (SHOTGUN_SPREAD_ANGLE / (SHOTGUN_BULLET_COUNT > 1 ? SHOTGUN_BULLET_COUNT - 1 : 1)) * (i - (SHOTGUN_BULLET_COUNT - 1) / 2); let fireAngle = baseAngle + angleOffset; let vx = cos(fireAngle) * BULLET_SPEED; let vy = sin(fireAngle) * BULLET_SPEED; bullets.push(new Bullet(player.x, player.y, vx, vy, BULLET_RADIUS, BRONZE_COLOR)); } }
                                else if (currentWeaponType === WEAPON_BOUNCY) { bullets.push(new BouncyBullet(player.x, player.y, baseVX, baseVY)); }
                                else { bullets.push(new Bullet(player.x, player.y, baseVX, baseVY, BULLET_RADIUS, BRONZE_COLOR)); }
                                last_shot_time_ms = ctm;
                            }
                        }
                    } break;
                case STATE_MENU: if (!admin_panel_open) { if (playButton.isHovered) { current_state = STATE_LOAD_OR_NEW; } else if (resetButton.isHovered) { current_state = STATE_CONFIRM_RESET; } } break;
                case STATE_LOAD_OR_NEW: if (!admin_panel_open) { if (loadGameButton.isHovered && saved_wave > 1) { current_difficulty = DIFFICULTY_EASY; current_wave = saved_wave - 1; wave_completed_flag = true; shopScrollY = 0; current_state = STATE_SHOP; } else if (newGameButton.isHovered) { current_state = STATE_DIFFICULTY_SELECT; } } break;
                case STATE_DIFFICULTY_SELECT: if (!admin_panel_open) { if (easyModeButton.isHovered) { current_difficulty = DIFFICULTY_EASY; localStorage.removeItem('shootyGameCurrentWave'); saved_wave = 1; start_new_game_or_wave(1); } else if (hardModeButton.isHovered) { current_difficulty = DIFFICULTY_HARD; localStorage.removeItem('shootyGameCurrentWave'); saved_wave = 1; start_new_game_or_wave(1); } } break;
                case STATE_SHOP:
                    if (!admin_panel_open) {
                        let effectiveMouseY = mouseY - shopVisibleStartY + shopScrollY;
                        let mouseInShopArea = mouseX > 0 && mouseX < width && mouseY > shopVisibleStartY && mouseY < shopVisibleStartY + shopVisibleHeight;
                        if (mouseInShopArea) {
                            let speedCost = getShopSpeedCost(); let lifeCost = getShopBuyLifeCost(); let autoFireCost = getShopAutoFireCost(); let bouncyCost = getShopBouncyGunCost(); let shotgunCost = getShopShotgunCost(); let machineGunCost = getShopMachineGunCost();
                            if (spdBuyButton.isHovered && spdBuyButton.isActive) { if (total_coins >= speedCost) { total_coins -= speedCost; speed_level++; localStorage.setItem('shootyGameTotalCoins', total_coins.toString()); localStorage.setItem('shootyGameSpeedLevel', speed_level.toString()); current_player_speed = calculate_player_speed(); } }
                            else if (buyLifeButton.isHovered && buyLifeButton.isActive) { if (total_coins >= lifeCost) { total_coins -= lifeCost; player_lives++; localStorage.setItem('shootyGameTotalCoins', total_coins.toString()); } }
                            else if (autoBuyButton.isHovered && autoBuyButton.isActive && !auto_fire_purchased) { if (total_coins >= autoFireCost) { total_coins -= autoFireCost; auto_fire_purchased = true; auto_fire_active = true; localStorage.setItem('shootyGameTotalCoins', total_coins.toString()); localStorage.setItem('shootyGameAutoFirePurchased', 'true'); } }
                            else if (bouncyGunBuyButton.isHovered && bouncyGunBuyButton.isActive) { if (!bouncyGunPurchased) { if (total_coins >= bouncyCost) { total_coins -= bouncyCost; bouncyGunPurchased = true; localStorage.setItem('shootyGameTotalCoins', total_coins.toString()); localStorage.setItem('shootyGameBouncyGunPurchased', 'true'); currentWeaponType = WEAPON_BOUNCY; } } else { currentWeaponType = WEAPON_BOUNCY; } }
                            else if (shotgunBuyButton.isHovered && shotgunBuyButton.isActive) { if (!shotgunPurchased) { if (total_coins >= shotgunCost) { total_coins -= shotgunCost; shotgunPurchased = true; localStorage.setItem('shootyGameTotalCoins', total_coins.toString()); localStorage.setItem('shootyGameShotgunPurchased', 'true'); currentWeaponType = WEAPON_SHOTGUN; } } else { currentWeaponType = WEAPON_SHOTGUN; } }
                            else if (machineGunBuyButton.isHovered && machineGunBuyButton.isActive) { if (!machineGunPurchased) { if (total_coins >= machineGunCost) { total_coins -= machineGunCost; machineGunPurchased = true; localStorage.setItem('shootyGameTotalCoins', total_coins.toString()); localStorage.setItem('shootyGameMachineGunPurchased', 'true'); currentWeaponType = WEAPON_MACHINE_GUN; } } else { currentWeaponType = WEAPON_MACHINE_GUN; } }
                            else if (standardGunEquipButton.isHovered && standardGunEquipButton.isActive) { currentWeaponType = WEAPON_STANDARD; }
                        }
                    } break;
                case STATE_GAME_OVER:
                    if (gameOverRestartButton.isHovered) start_new_game_or_wave(1);
                    else if (gameOverMenuButton.isHovered) {
                        current_state = STATE_MENU;
                        total_coins = parseInt(localStorage.getItem('shootyGameTotalCoins') || '0', 10); // Reload coins for menu
                    }
                    break;
                case STATE_CONFIRM_RESET: if (confirmYesButton.isHovered) { localStorage.removeItem('shootyGameTotalCoins'); localStorage.removeItem('shootyGameSpeedLevel'); localStorage.removeItem('shootyGameAutoFirePurchased'); localStorage.removeItem('shootyGameBouncyGunPurchased'); localStorage.removeItem('shootyGameShotgunPurchased'); localStorage.removeItem('shootyGameMachineGunPurchased'); localStorage.removeItem('shootyGameCurrentWave'); total_coins = 0; speed_level = 0; auto_fire_purchased = false; auto_fire_active = false; bouncyGunPurchased = false; shotgunPurchased = false; machineGunPurchased = false; currentWeaponType = WEAPON_STANDARD; saved_wave = 1; current_difficulty = DIFFICULTY_EASY; is_admin = false; admin_panel_open = false; cheat_input_buffer = ""; player_lives = PLAYER_MAX_LIVES; current_run_score = 0; current_player_speed = calculate_player_speed(); current_bullet_damage = BASE_BULLET_DAMAGE; location.reload(); } else if (confirmNoButton.isHovered) { current_state = STATE_MENU; } break;
             }
         }

        // --- p5.js Setup Function ---
        function setup() {
            createCanvas(600, 400);
            playButton.x = width/2 - playButton.w/2; playButton.y = height/2 - playButton.h/2 - 40;
            resetButton.x = width/2 - resetButton.w/2; resetButton.y = playButton.y + playButton.h + 20;
            loadGameButton.x = width/2 - loadGameButton.w/2; loadGameButton.y = height/2 - loadGameButton.h/2 - 35;
            newGameButton.x = width/2 - newGameButton.w/2; newGameButton.y = loadGameButton.y + loadGameButton.h + 20;
            easyModeButton.x = width/2 - easyModeButton.w/2; easyModeButton.y = height/2 - easyModeButton.h/2 - 35;
            hardModeButton.x = width/2 - hardModeButton.w/2; hardModeButton.y = easyModeButton.y + easyModeButton.h + 20;

            gameOverRestartButton.x = width / 2 - gameOverRestartButton.w / 2;
            gameOverRestartButton.y = height * 0.65;
            gameOverMenuButton.x = width / 2 - gameOverMenuButton.w / 2;
            gameOverMenuButton.y = gameOverRestartButton.y + gameOverRestartButton.h + 15;


            current_state = STATE_MENU; player_lives = PLAYER_MAX_LIVES; is_admin = false; admin_panel_open = false; cheat_input_buffer = ""; textAlign(CENTER, CENTER);
            shopVisibleHeight = height - shopVisibleStartY - 20;
            saved_wave = parseInt(localStorage.getItem('shootyGameCurrentWave') || '1', 10);
            total_coins = parseInt(localStorage.getItem('shootyGameTotalCoins') || '0', 10); // Initial load of total_coins
         }

        // --- p5.js Draw Function ---
        function draw() {
            let current_time_ms = millis();
            let effectiveMouseY = mouseY - shopVisibleStartY + shopScrollY;
            let mouseInShopArea = current_state === STATE_SHOP && mouseX > 0 && mouseX < width && mouseY > shopVisibleStartY && mouseY < shopVisibleStartY + shopVisibleHeight;

            playButton.isHovered = false; resetButton.isHovered = false; loadGameButton.isHovered = false; newGameButton.isHovered = false; easyModeButton.isHovered = false; hardModeButton.isHovered = false; spdBuyButton.isHovered = false; buyLifeButton.isHovered = false; autoBuyButton.isHovered = false; standardGunEquipButton.isHovered = false; bouncyGunBuyButton.isHovered = false; shotgunBuyButton.isHovered = false; machineGunBuyButton.isHovered = false; confirmYesButton.isHovered = false; confirmNoButton.isHovered = false; gameOverRestartButton.isHovered = false; gameOverMenuButton.isHovered = false;

            if (current_state === STATE_MENU) { playButton.isHovered = !admin_panel_open && (mouseX > playButton.x && mouseX < playButton.x + playButton.w && mouseY > playButton.y && mouseY < playButton.y + playButton.h); resetButton.isHovered = !admin_panel_open && (mouseX > resetButton.x && mouseX < resetButton.x + resetButton.w && mouseY > resetButton.y && mouseY < resetButton.y + resetButton.h); }
            else if (current_state === STATE_LOAD_OR_NEW) { if (saved_wave > 1) { loadGameButton.isHovered = !admin_panel_open && (mouseX > loadGameButton.x && mouseX < loadGameButton.x + loadGameButton.w && mouseY > loadGameButton.y && mouseY < loadGameButton.y + loadGameButton.h); } newGameButton.isHovered = !admin_panel_open && (mouseX > newGameButton.x && mouseX < newGameButton.x + newGameButton.w && mouseY > newGameButton.y && mouseY < newGameButton.y + newGameButton.h); }
            else if (current_state === STATE_DIFFICULTY_SELECT) { easyModeButton.isHovered = !admin_panel_open && (mouseX > easyModeButton.x && mouseX < easyModeButton.x + easyModeButton.w && mouseY > easyModeButton.y && mouseY < easyModeButton.y + easyModeButton.h); hardModeButton.isHovered = !admin_panel_open && (mouseX > hardModeButton.x && mouseX < hardModeButton.x + hardModeButton.w && mouseY > hardModeButton.y && mouseY < hardModeButton.y + hardModeButton.h); }
            else if (current_state === STATE_SHOP) {
                spdBuyButton.isActive = total_coins >= getShopSpeedCost(); buyLifeButton.isActive = total_coins >= getShopBuyLifeCost(); autoBuyButton.isActive = !auto_fire_purchased && total_coins >= getShopAutoFireCost(); bouncyGunBuyButton.isActive = (!bouncyGunPurchased && total_coins >= getShopBouncyGunCost()) || (bouncyGunPurchased && currentWeaponType !== WEAPON_BOUNCY); shotgunBuyButton.isActive = (!shotgunPurchased && total_coins >= getShopShotgunCost()) || (shotgunPurchased && currentWeaponType !== WEAPON_SHOTGUN); machineGunBuyButton.isActive = (!machineGunPurchased && total_coins >= getShopMachineGunCost()) || (machineGunPurchased && currentWeaponType !== WEAPON_MACHINE_GUN); standardGunEquipButton.isActive = currentWeaponType !== WEAPON_STANDARD;
                spdBuyButton.isHovered = mouseInShopArea && spdBuyButton.isActive && !admin_panel_open && (mouseX > spdBuyButton.x && mouseX < spdBuyButton.x + spdBuyButton.w && effectiveMouseY > spdBuyButton.y && effectiveMouseY < spdBuyButton.y + spdBuyButton.h); buyLifeButton.isHovered = mouseInShopArea && buyLifeButton.isActive && !admin_panel_open && (mouseX > buyLifeButton.x && mouseX < buyLifeButton.x + buyLifeButton.w && effectiveMouseY > buyLifeButton.y && effectiveMouseY < buyLifeButton.y + buyLifeButton.h); autoBuyButton.isHovered = mouseInShopArea && autoBuyButton.isActive && !admin_panel_open && (mouseX > autoBuyButton.x && mouseX < autoBuyButton.x + autoBuyButton.w && effectiveMouseY > autoBuyButton.y && effectiveMouseY < autoBuyButton.y + autoBuyButton.h); bouncyGunBuyButton.isHovered = mouseInShopArea && bouncyGunBuyButton.isActive && !admin_panel_open && (mouseX > bouncyGunBuyButton.x && mouseX < bouncyGunBuyButton.x + bouncyGunBuyButton.w && effectiveMouseY > bouncyGunBuyButton.y && effectiveMouseY < bouncyGunBuyButton.y + bouncyGunBuyButton.h); shotgunBuyButton.isHovered = mouseInShopArea && shotgunBuyButton.isActive && !admin_panel_open && (mouseX > shotgunBuyButton.x && mouseX < shotgunBuyButton.x + shotgunBuyButton.w && effectiveMouseY > shotgunBuyButton.y && effectiveMouseY < shotgunBuyButton.y + shotgunBuyButton.h); machineGunBuyButton.isHovered = mouseInShopArea && machineGunBuyButton.isActive && !admin_panel_open && (mouseX > machineGunBuyButton.x && mouseX < machineGunBuyButton.x + machineGunBuyButton.w && effectiveMouseY > machineGunBuyButton.y && effectiveMouseY < machineGunBuyButton.y + machineGunBuyButton.h); standardGunEquipButton.isHovered = mouseInShopArea && standardGunEquipButton.isActive && !admin_panel_open && (mouseX > standardGunEquipButton.x && mouseX < standardGunEquipButton.x + standardGunEquipButton.w && effectiveMouseY > standardGunEquipButton.y && effectiveMouseY < standardGunEquipButton.y + standardGunEquipButton.h);
            } else if (current_state === STATE_CONFIRM_RESET) { confirmYesButton.isHovered = (mouseX > confirmYesButton.x && mouseX < confirmYesButton.x + confirmYesButton.w && mouseY > confirmYesButton.y && mouseY < confirmYesButton.y + confirmYesButton.h); confirmNoButton.isHovered = (mouseX > confirmNoButton.x && mouseX < confirmNoButton.x + confirmNoButton.w && mouseY > confirmNoButton.y && mouseY < confirmNoButton.y + confirmNoButton.h);
            } else if (current_state === STATE_GAME_OVER) {
                gameOverRestartButton.isHovered = (mouseX > gameOverRestartButton.x && mouseX < gameOverRestartButton.x + gameOverRestartButton.w && mouseY > gameOverRestartButton.y && mouseY < gameOverRestartButton.y + gameOverRestartButton.h);
                gameOverMenuButton.isHovered = (mouseX > gameOverMenuButton.x && mouseX < gameOverMenuButton.x + gameOverMenuButton.w && mouseY > gameOverMenuButton.y && mouseY < gameOverMenuButton.y + gameOverMenuButton.h);
            }


            if (isAudioSetup && menuSequence) { if (current_state === STATE_MENU && Tone.Transport.state !== 'started') { Tone.Transport.start(); menuSequence.start(0); } else if (current_state !== STATE_MENU && Tone.Transport.state === 'started') { menuSequence.stop(); Tone.Transport.stop(); } }
            if (playerIsHit) { playerHitTimer--; if (playerHitTimer <= 0) { playerIsHit = false; } }
            if (current_state === STATE_PLAYING && player && !admin_panel_open) { aimHistory.push({ timestamp: millis(), playerX: player.x, playerY: player.y, aimX: mouseX, aimY: mouseY }); aimHistory = aimHistory.filter(p => millis() - p.timestamp < MACHINE_GUN_LAG_MS + 1000); }

            const defaultButtonShadow = { offsetX: 2, offsetY: 2, blurRadius: 4, color: BUTTON_SHADOW_COLOR };
            const titleTextShadow = { offsetX: 2, offsetY: 2, blurRadius: 3, color: TITLE_SHADOW_COLOR };
            const panelDropShadow = { offsetX: 4, offsetY: 4, blurRadius: 8, color: PANEL_SHADOW_COLOR };

            switch (current_state) {
                case STATE_MENU:
                     background(MENU_BG_COLOR);
                     textAlign(CENTER, CENTER);
                     applyShadow(titleTextShadow.offsetX, titleTextShadow.offsetY, titleTextShadow.blurRadius, titleTextShadow.color);
                     fill(MENU_TITLE_COLOR); textSize(56);
                     text("Shooty Game", width / 2, height * 0.25);
                     clearShadow();

                     drawStyledButton(playButton.x, playButton.y, playButton.w, playButton.h, "Play", { baseColor: BUTTON_SUCCESS_COLOR, hoverColor: BUTTON_SUCCESS_HOVER, inactiveColor: BUTTON_SUCCESS_COLOR, textColor: BUTTON_TEXT_COLOR, isHovered: playButton.isHovered, isActive: true, cornerRadius: BUTTON_CORNER_RADIUS, shadowOptions: defaultButtonShadow, textOptions: { size: 26 } });
                     drawStyledButton(resetButton.x, resetButton.y, resetButton.w, resetButton.h, "Reset Data ", { baseColor: BUTTON_DANGER_COLOR, hoverColor: BUTTON_DANGER_HOVER, inactiveColor: BUTTON_DANGER_COLOR, textColor: BUTTON_TEXT_COLOR, isHovered: resetButton.isHovered, isActive: true, cornerRadius: BUTTON_CORNER_RADIUS, shadowOptions: defaultButtonShadow, textOptions: { size: 18 } });
                     if (is_admin) { fill(MENU_ADMIN_TEXT_COLOR); textSize(14); textAlign(CENTER, BOTTOM); text("ADMIN MODE ACTIVE (P to open panel)", width / 2, height - 15); }
                     break;

                 case STATE_LOAD_OR_NEW:
                     background(MENU_BG_COLOR);
                     textAlign(CENTER, CENTER);
                     applyShadow(titleTextShadow.offsetX, titleTextShadow.offsetY, titleTextShadow.blurRadius, titleTextShadow.color);
                     fill(MENU_TITLE_COLOR); textSize(44); text("Start Game", width / 2, height * 0.25);
                     clearShadow();
                     let currentYLON = height / 2 - 35;
                     if (saved_wave <= 1) { currentYLON = height / 2 - newGameButton.h / 2; }
                     if (saved_wave > 1) {
                         loadGameButton.y = currentYLON;
                         drawStyledButton(loadGameButton.x, loadGameButton.y, loadGameButton.w, loadGameButton.h, `Load Game (Wave ${saved_wave})`, { baseColor: BUTTON_PRIMARY_COLOR, hoverColor: BUTTON_PRIMARY_HOVER, inactiveColor: BUTTON_PRIMARY_COLOR, textColor: BUTTON_TEXT_COLOR, isHovered: loadGameButton.isHovered, isActive: true, cornerRadius: BUTTON_CORNER_RADIUS, shadowOptions: defaultButtonShadow, textOptions: { size: 22 } });
                         currentYLON += loadGameButton.h + 20;
                     }
                     newGameButton.y = currentYLON;
                     drawStyledButton(newGameButton.x, newGameButton.y, newGameButton.w, newGameButton.h, "New Game", { baseColor: BUTTON_SECONDARY_COLOR, hoverColor: BUTTON_SECONDARY_HOVER, inactiveColor: BUTTON_SECONDARY_COLOR, textColor: BUTTON_TEXT_COLOR, isHovered: newGameButton.isHovered, isActive: true, cornerRadius: BUTTON_CORNER_RADIUS, shadowOptions: defaultButtonShadow, textOptions: { size: 22 } });
                     break;

                 case STATE_DIFFICULTY_SELECT:
                     background(MENU_BG_COLOR);
                     textAlign(CENTER, CENTER);
                     applyShadow(titleTextShadow.offsetX, titleTextShadow.offsetY, titleTextShadow.blurRadius, titleTextShadow.color);
                     fill(MENU_TITLE_COLOR); textSize(44); text("Select Difficulty", width / 2, height * 0.25);
                     clearShadow();
                     drawStyledButton(easyModeButton.x, easyModeButton.y, easyModeButton.w, easyModeButton.h, "Easy", { baseColor: BUTTON_SUCCESS_COLOR, hoverColor: BUTTON_SUCCESS_HOVER, inactiveColor: BUTTON_SUCCESS_COLOR, textColor: BUTTON_TEXT_COLOR, isHovered: easyModeButton.isHovered, isActive: true, cornerRadius: BUTTON_CORNER_RADIUS, shadowOptions: defaultButtonShadow, textOptions: { size: 24 } });
                     drawStyledButton(hardModeButton.x, hardModeButton.y, hardModeButton.w, hardModeButton.h, "Hard", { baseColor: BUTTON_DANGER_COLOR, hoverColor: BUTTON_DANGER_HOVER, inactiveColor: BUTTON_DANGER_COLOR, textColor: BUTTON_TEXT_COLOR, isHovered: hardModeButton.isHovered, isActive: true, cornerRadius: BUTTON_CORNER_RADIUS, shadowOptions: defaultButtonShadow, textOptions: { size: 24 } });
                     break;

                case STATE_SHOP:
                     background(SHOP_BG_COLOR);
                     textAlign(CENTER, TOP);
                     applyShadow(titleTextShadow.offsetX, titleTextShadow.offsetY, titleTextShadow.blurRadius, TITLE_SHADOW_COLOR);
                     fill(SHOP_TEXT_COLOR); textSize(SHOP_TITLE_TEXT_SIZE);
                     if (wave_completed_flag) { text(`Wave ${current_wave} Complete!`, width / 2, 25); } else { text("SHOP", width / 2, 25); }
                     clearShadow();
                     textSize(18); text("Total Coins: " + total_coins, width / 2, 25 + SHOP_TITLE_TEXT_SIZE + 8);
                     shopVisibleStartY = 25 + SHOP_TITLE_TEXT_SIZE + 8 + 18 + 15; // Adjusted after removing Gemini button

                     let cardX = SHOP_CARD_MARGIN; let cardWidth = width - 2 * SHOP_CARD_MARGIN;
                     let currentContentY = 0; let headerX = cardX + SHOP_CARD_PADDING;
                     let textX = cardX + SHOP_CARD_PADDING; let buttonX = cardX + cardWidth - SHOP_CARD_PADDING - SHOP_BUTTON_WIDTH;

                     function drawShopItemCard(relativeY, title, costText, costValue, buttonObj, buttonLabel, itemType = null, weaponTypeConst = null) {
                         let cardHeight = SHOP_BUTTON_HEIGHT + 2 * SHOP_CARD_PADDING + 5;
                         let isWeapon = itemType === 'weapon'; let isAbility = itemType === 'ability'; let isLife = itemType === 'life';
                         let isPurchased = false; let isEquipped = false;
                         if (isWeapon) { if (weaponTypeConst === WEAPON_BOUNCY) isPurchased = bouncyGunPurchased; else if (weaponTypeConst === WEAPON_SHOTGUN) isPurchased = shotgunPurchased; else if (weaponTypeConst === WEAPON_MACHINE_GUN) isPurchased = machineGunPurchased; else if (weaponTypeConst === WEAPON_STANDARD) isPurchased = true; isEquipped = currentWeaponType === weaponTypeConst; }
                         else if (isAbility && buttonObj === autoBuyButton) { isPurchased = auto_fire_purchased; }
                         else if (isLife) { isPurchased = false; }

                         if (relativeY + cardHeight > shopScrollY && relativeY < shopScrollY + shopVisibleHeight) {
                            applyShadow(panelDropShadow.offsetX / 2, panelDropShadow.offsetY / 2, panelDropShadow.blurRadius / 2, PANEL_SHADOW_COLOR);
                            fill(SHOP_CARD_COLOR); stroke(SHOP_CARD_STROKE); strokeWeight(1); rect(cardX, relativeY, cardWidth, cardHeight, BUTTON_CORNER_RADIUS);
                            clearShadow();

                            noStroke(); fill(SHOP_TEXT_COLOR);
                            textAlign(LEFT, TOP); textSize(SHOP_ITEM_TEXT_SIZE); text(title, textX, relativeY + SHOP_CARD_PADDING + 3);
                            textSize(SHOP_COST_TEXT_SIZE);
                            if (buttonLabel !== "Placeholder" && !isWeapon && !isAbility && !isLife) { text(costText, textX, relativeY + SHOP_CARD_PADDING + SHOP_ITEM_TEXT_SIZE + 7); }
                            else if ((isWeapon || isAbility || isLife) && !isPurchased) { text(costText, textX, relativeY + SHOP_CARD_PADDING + SHOP_ITEM_TEXT_SIZE + 7); }
                            else if (isAbility && isPurchased) { text(costText, textX, relativeY + SHOP_CARD_PADDING + SHOP_ITEM_TEXT_SIZE + 7); }

                            buttonObj.x = buttonX; buttonObj.y = relativeY + cardHeight / 2 - SHOP_BUTTON_HEIGHT / 2;
                            let currentButtonText = buttonLabel; let canAfford = total_coins >= costValue;
                            let btnBase = SHOP_BUTTON_COLOR_ACTIVE, btnHover = SHOP_BUTTON_COLOR_HOVER, btnInactive = SHOP_BUTTON_COLOR_INACTIVE;

                            if (buttonLabel === "Placeholder") { buttonObj.isActive = false; currentButtonText = "???"; }
                            else if (isWeapon) { if (!isPurchased) { buttonObj.isActive = canAfford; currentButtonText = "Buy"; } else if (isEquipped) { buttonObj.isActive = false; currentButtonText = "Equipped"; } else { buttonObj.isActive = true; currentButtonText = "Equip"; } }
                            else if (isAbility && buttonObj === autoBuyButton) { if (!isPurchased) { buttonObj.isActive = canAfford; currentButtonText = "Buy"; } else { buttonObj.isActive = false; currentButtonText = "Purchased"; } }
                            else if (isLife) { buttonObj.isActive = canAfford; currentButtonText = "Buy"; }
                            else { buttonObj.isActive = canAfford; currentButtonText = "Upgrade"; }

                            drawStyledButton(buttonObj.x, buttonObj.y, buttonObj.w, buttonObj.h, currentButtonText, { baseColor: btnBase, hoverColor: btnHover, inactiveColor: btnInactive, textColor: SHOP_BUTTON_TEXT_COLOR, isHovered: buttonObj.isHovered, isActive: buttonObj.isActive, cornerRadius: BUTTON_CORNER_RADIUS -2, shadowOptions: defaultButtonShadow, textOptions: {size: 14} });

                            if (!canAfford && buttonObj.isActive === false && buttonLabel !== "Placeholder" && buttonLabel !== "Equip" && buttonLabel !== "Equipped" && currentButtonText !== "Max Lives") { fill(GRAY_TEXT_COLOR); textAlign(LEFT, TOP); text("(Not Enough)", textX, relativeY + SHOP_CARD_PADDING + SHOP_ITEM_TEXT_SIZE + SHOP_COST_TEXT_SIZE + 9); }
                         }
                         return relativeY + cardHeight + SHOP_CARD_MARGIN;
                     }
                     push(); translate(0, shopVisibleStartY - shopScrollY);
                     fill(SHOP_TEXT_COLOR); textSize(SHOP_CATEGORY_HEADER_SIZE); textAlign(LEFT, TOP);
                     if (currentContentY + SHOP_CATEGORY_HEADER_SIZE > shopScrollY && currentContentY < shopScrollY + shopVisibleHeight) { text("--- Upgrades ---", headerX, currentContentY); }
                     currentContentY += SHOP_CATEGORY_HEADER_SIZE + SHOP_HEADER_MARGIN_BOTTOM;
                     let spdCost = getShopSpeedCost(); let spdValue = calculate_player_speed(); currentContentY = drawShopItemCard(currentContentY, `Speed Lvl: ${speed_level} (Val: ${spdValue.toFixed(2)})`, `Cost: ${spdCost}`, spdCost, spdBuyButton, "Upgrade");
                     let lifeCost = getShopBuyLifeCost(); currentContentY = drawShopItemCard(currentContentY, `Buy 1 Life (Current: ${player_lives})`, `Cost: ${lifeCost}`, lifeCost, buyLifeButton, "Buy", 'life');
                     currentContentY += SHOP_CATEGORY_MARGIN_TOP - SHOP_CARD_MARGIN; fill(SHOP_TEXT_COLOR); textSize(SHOP_CATEGORY_HEADER_SIZE); textAlign(LEFT, TOP);
                     if (currentContentY + SHOP_CATEGORY_HEADER_SIZE > shopScrollY && currentContentY < shopScrollY + shopVisibleHeight) { text("--- Weapons ---", headerX, currentContentY); }
                     currentContentY += SHOP_CATEGORY_HEADER_SIZE + SHOP_HEADER_MARGIN_BOTTOM;
                     currentContentY = drawShopItemCard(currentContentY, "Standard Gun", "", 0, standardGunEquipButton, "Equip", 'weapon', WEAPON_STANDARD);
                     let bouncyCost = getShopBouncyGunCost(); let bouncyCostText = bouncyGunPurchased ? "" : `Cost: ${bouncyCost}`; currentContentY = drawShopItemCard(currentContentY, "Bouncy Gun", bouncyCostText, bouncyCost, bouncyGunBuyButton, "Buy", 'weapon', WEAPON_BOUNCY);
                     let shotgunCost = getShopShotgunCost(); let shotgunCostText = shotgunPurchased ? "" : `Cost: ${shotgunCost}`; currentContentY = drawShopItemCard(currentContentY, "Shotgun", shotgunCostText, shotgunCost, shotgunBuyButton, "Buy", 'weapon', WEAPON_SHOTGUN);
                     let machineGunCost = getShopMachineGunCost(); let machineGunCostText = machineGunPurchased ? "" : `Cost: ${machineGunCost}`; currentContentY = drawShopItemCard(currentContentY, "Machine Gun", machineGunCostText, machineGunCost, machineGunBuyButton, "Buy", 'weapon', WEAPON_MACHINE_GUN);
                     let autoFireCost = getShopAutoFireCost(); let autoCostText = auto_fire_purchased ? "(Press Q to toggle)" : `Cost: ${autoFireCost}`; currentContentY = drawShopItemCard(currentContentY, "Auto-Fire Ability", autoCostText, autoFireCost, autoBuyButton, "Buy", 'ability');
                     pop();
                     shopContentHeight = currentContentY; shopVisibleHeight = height - shopVisibleStartY - 20; shopScrollableHeight = max(0, shopContentHeight - shopVisibleHeight); shopScrollY = constrain(shopScrollY, 0, shopScrollableHeight);
                     break;

                case STATE_GAME_OVER:
                      background(GAME_OVER_BG_COLOR);
                      textAlign(CENTER, CENTER);
                      applyShadow(3, 3, 6, [0,0,0,150]);
                      fill(GAME_OVER_TITLE_COLOR); textSize(72);
                      text("GAME OVER", width / 2, height * 0.25);
                      clearShadow();

                      let statY = height * 0.45;
                      fill(GAME_OVER_TEXT_COLOR);
                      applyShadow(1,1,2, [0,0,0,100]);
                      textSize(24); text(`Wave Reached: ${current_wave}`, width / 2, statY); statY += 35;
                      textSize(20); text(`Score This Run: ${current_run_score}`, width / 2, statY); statY += 30;
                      textSize(18); text(`Total Coins (Pre-Run): ${total_coins}`, width / 2, statY); // This total_coins is now pre-run
                      clearShadow();

                      statY += 50;
                      gameOverRestartButton.y = statY;
                      drawStyledButton(gameOverRestartButton.x, gameOverRestartButton.y, gameOverRestartButton.w, gameOverRestartButton.h, "Restart", { baseColor: BUTTON_PRIMARY_COLOR, hoverColor: BUTTON_PRIMARY_HOVER, inactiveColor: BUTTON_PRIMARY_COLOR, textColor: BUTTON_TEXT_COLOR, isHovered: gameOverRestartButton.isHovered, isActive: true, cornerRadius: BUTTON_CORNER_RADIUS, shadowOptions: defaultButtonShadow, textOptions: {size: 20} });
                      gameOverMenuButton.y = statY + gameOverRestartButton.h + 15;
                      drawStyledButton(gameOverMenuButton.x, gameOverMenuButton.y, gameOverMenuButton.w, gameOverMenuButton.h, "Main Menu", { baseColor: BUTTON_SECONDARY_COLOR, hoverColor: BUTTON_SECONDARY_HOVER, inactiveColor: BUTTON_SECONDARY_COLOR, textColor: BUTTON_TEXT_COLOR, isHovered: gameOverMenuButton.isHovered, isActive: true, cornerRadius: BUTTON_CORNER_RADIUS, shadowOptions: defaultButtonShadow, textOptions: {size: 18} });
                      break;

                case STATE_PLAYING:
                    background(BACKGROUND_COLOR);
                    if (player) { player.update(); check_player_powerup_collision(player, powerups); }
                    if (time_stop_active && current_time_ms >= time_stop_end_time_ms) { time_stop_active = false; }
                    if (auto_fire_active && player && currentWeaponType !== WEAPON_MACHINE_GUN) { auto_aim_target = find_closest_enemy(player.x, player.y, enemies); } else { auto_aim_target = null; }
                    if (!time_stop_active && !admin_panel_open) {
                        let elapsed_wave_time_sec = (current_time_ms - wave_timer_start_ms) / 1000.0;
                        if (elapsed_wave_time_sec >= WAVE_DURATION_SEC) { total_coins += current_run_score; localStorage.setItem('shootyGameTotalCoins', total_coins.toString()); localStorage.setItem('shootyGameCurrentWave', (current_wave + 1).toString()); current_run_score = 0; wave_completed_flag = true; bullets = []; powerups = []; homing_shot_ready = false; explosionParticles = []; shopScrollY = 0; current_state = STATE_SHOP; return;
                        } else {
                            if (current_time_ms - last_timestop_chance_check_time_ms >= TIME_STOP_CHECK_INTERVAL_MS) { if (!time_stop_ready && !time_stop_active) { if (random() < TIME_STOP_CHANCE) { time_stop_ready = true; } } last_timestop_chance_check_time_ms += TIME_STOP_CHECK_INTERVAL_MS; }
                            for (let i = bullets.length - 1; i >= 0; i--) { if (bullets[i]) { bullets[i].update(); if (bullets[i].is_offscreen() || bullets[i].isDead) { bullets.splice(i, 1); } } else { bullets.splice(i, 1); } }
                            for (let i = enemies.length - 1; i >= 0; i--) { if (enemies[i]) { enemies[i].update(player?.x, player?.y); } else { enemies.splice(i, 1); } }
                            spawn_timer++; if (spawn_timer >= current_enemy_spawn_rate) { spawn_enemy(); spawn_timer = 0; }
                            if (current_time_ms - last_blue_spawn_time_ms >= current_blue_spawn_interval_sec * 1000) { spawn_blue_enemy(); last_blue_spawn_time_ms = current_time_ms; }
                            if (current_time_ms - last_powerup_spawn_time_ms >= POWERUP_SPAWN_INTERVAL_SEC * 1000) { spawn_powerup(); last_powerup_spawn_time_ms = current_time_ms; }
                            let ctm = millis(); let cooldown = SHOOT_COOLDOWN_MS; if (currentWeaponType === WEAPON_SHOTGUN) cooldown = SHOTGUN_COOLDOWN_MS; else if (currentWeaponType === WEAPON_MACHINE_GUN) cooldown = MACHINE_GUN_COOLDOWN_MS;
                            if (currentWeaponType === WEAPON_MACHINE_GUN && player) { if (ctm - last_shot_time_ms >= cooldown) { let laggedAim = getLaggedAim(MACHINE_GUN_LAG_MS); let aimDX = mouseX - player.x; let aimDY = mouseY - player.y; if (laggedAim) { aimDX = laggedAim.dx; aimDY = laggedAim.dy; } let dist = sqrt(aimDX * aimDX + aimDY * aimDY); if (dist > 0) { let vx = (aimDX / dist) * BULLET_SPEED; let vy = (aimDY / dist) * BULLET_SPEED; bullets.push(new Bullet(player.x, player.y, vx, vy, BULLET_RADIUS, BRONZE_COLOR)); last_shot_time_ms = ctm; } } }
                            else if (auto_fire_active && player && auto_aim_target) { if (ctm - last_shot_time_ms >= cooldown) { let aimDX = auto_aim_target.x - player.x; let aimDY = auto_aim_target.y - player.y; let dist = sqrt(aimDX * aimDX + aimDY * aimDY); if (dist > 0) { let baseAngle = atan2(aimDY, aimDX); let baseVX = (aimDX / dist) * BULLET_SPEED; let baseVY = (aimDY / dist) * BULLET_SPEED; if (homing_shot_ready) { bullets.push(new HomingBullet(player.x, player.y, baseVX, baseVY, BULLET_RADIUS, BRONZE_COLOR, auto_aim_target)); homing_shot_ready = false; } else if (currentWeaponType === WEAPON_SHOTGUN) { for (let i = 0; i < SHOTGUN_BULLET_COUNT; i++) { let angleOffset = (SHOTGUN_SPREAD_ANGLE / (SHOTGUN_BULLET_COUNT > 1 ? SHOTGUN_BULLET_COUNT - 1 : 1)) * (i - (SHOTGUN_BULLET_COUNT - 1) / 2); let fireAngle = baseAngle + angleOffset; let vx = cos(fireAngle) * BULLET_SPEED; let vy = sin(fireAngle) * BULLET_SPEED; bullets.push(new Bullet(player.x, player.y, vx, vy, BULLET_RADIUS, BRONZE_COLOR)); } } else if (currentWeaponType === WEAPON_BOUNCY) { bullets.push(new BouncyBullet(player.x, player.y, baseVX, baseVY)); } else { bullets.push(new Bullet(player.x, player.y, baseVX, baseVY, BULLET_RADIUS, BRONZE_COLOR)); } last_shot_time_ms = ctm; } } }
                        }
                    }
                    for (let i = explosionParticles.length - 1; i >= 0; i--) { explosionParticles[i].update(); explosionParticles[i].display(); if (explosionParticles[i].isDead()) { explosionParticles.splice(i, 1); } }
                    for (let i = bullets.length - 1; i >= 0; i--) { if (!bullets[i]) continue; let bullet = bullets[i]; let bullet_removed = false; for (let j = enemies.length - 1; j >= 0; j--) { if (!enemies[j]) continue; let enemy = enemies[j]; let distSq = (bullet.x - enemy.x)**2 + (bullet.y - enemy.y)**2; let radiiSq = (bullet.radius + enemy.radius)**2; if (distSq <= radiiSq) { let damageToDeal = (bullet instanceof BouncyBullet) ? bullet.damage : current_bullet_damage; if (enemy.take_damage(damageToDeal)) { current_run_score += enemy.reward; if (coinSynth && isAudioSetup) { coinSynth.triggerAttackRelease("G5", "16n", Tone.now()); } for (let k = 0; k < EXPLOSION_PARTICLE_COUNT; k++) { explosionParticles.push(new ExplosionParticle(enemy.x, enemy.y, enemy.color)); } if (enemy === auto_aim_target) { auto_aim_target = null; } enemies.splice(j, 1); } if (bullet instanceof BouncyBullet) { bullet.handleEnemyBounce(); } else { if (!bullet_removed) { bullets.splice(i, 1); bullet_removed = true; break; } } } } }
                    if (player && !playerIsHit) { for (let j = enemies.length - 1; j >= 0; j--) { if (!enemies[j]) continue; let enemy = enemies[j]; let distSq = (enemy.x - player.x)**2 + (enemy.y - player.y)**2; let radiiSq = (enemy.radius + player.radius)**2; if (distSq <= radiiSq) { if (enemy.hp > 0) { player_lives -= enemy.hp; playerIsHit = true; playerHitTimer = PLAYER_HIT_DURATION; enemies.splice(j, 1); if (player_lives <= 0) {
                        // total_coins += current_run_score; // DO NOT add current run's score to total_coins if they are lost on death
                        localStorage.removeItem('shootyGameTotalCoins'); // Clears persistent storage of coins
                        localStorage.removeItem('shootyGameCurrentWave');
                        saved_wave = 1;
                        // current_run_score is preserved to be shown on game over screen
                        // total_coins variable in memory now reflects coins *before* this run
                        explosionParticles = []; current_state = STATE_GAME_OVER; break;
                    } } else { enemies.splice(j, 1); } } } }

                    if (player && !admin_panel_open) { let aim_dx = mouseX - player.x; let aim_dy = mouseY - player.y; if (auto_fire_active && auto_aim_target && currentWeaponType !== WEAPON_MACHINE_GUN) { aim_dx = auto_aim_target.x - player.x; aim_dy = auto_aim_target.y - player.y; } if (currentWeaponType === WEAPON_MACHINE_GUN) { let laggedAim = getLaggedAim(MACHINE_GUN_LAG_MS); if (laggedAim) { aim_dx = laggedAim.dx; aim_dy = laggedAim.dy; } } let aim_dist = sqrt(aim_dx*aim_dx + aim_dy*aim_dy); if (aim_dist > 0) { stroke(LASER_SIGHT_COLOR); strokeWeight(LASER_SIGHT_WEIGHT); let baseAngle = atan2(aim_dy, aim_dx); let line_length = max(width,height)*1.5; if (currentWeaponType === WEAPON_SHOTGUN) { let angle1 = baseAngle - SHOTGUN_SPREAD_ANGLE/2; let angle2 = baseAngle + SHOTGUN_SPREAD_ANGLE/2; line(player.x,player.y, player.x+cos(angle1)*line_length, player.y+sin(angle1)*line_length); line(player.x,player.y, player.x+cos(angle2)*line_length, player.y+sin(angle2)*line_length); } else { line(player.x,player.y, player.x+(aim_dx/aim_dist)*line_length, player.y+(aim_dy/aim_dist)*line_length); } noStroke(); } }
                    if (player) { if (!playerIsHit || frameCount % 4 < 2) { player.display(); } }
                    for (let bullet of bullets) { if (bullet) bullet.display(); } for (let powerup of powerups) { if (powerup) powerup.display(); } noStroke(); for (let enemy of enemies) { if (enemy) enemy.display(); }

                    textAlign(LEFT, TOP); let hudY = 12; let time_remaining = max(0, WAVE_DURATION_SEC - ((millis() - wave_timer_start_ms) / 1000.0));
                    applyShadow(1, 1, 2, HUD_TEXT_SHADOW_COLOR); fill(SCORE_TEXT_COLOR); textSize(SCORE_TEXT_SIZE); text(`Wave: ${current_wave} | Time: ${time_remaining.toFixed(1)}`, 10, hudY); clearShadow();
                    hudY += SCORE_TEXT_SIZE + 3;
                    applyShadow(1, 1, 2, HUD_TEXT_SHADOW_COLOR); fill(LIVES_TEXT_COLOR); text(`Lives: ${max(0, player_lives)}`, 10, hudY); clearShadow();

                    let coinDisplayY = 12; let liveCoinValue = total_coins + current_run_score; let coinIconX = width - 15 - COIN_ICON_RADIUS; let coinIconY = coinDisplayY + COIN_ICON_RADIUS / 2 + 2; let coinTextX = coinIconX - COIN_ICON_RADIUS - 5;
                    push(); applyShadow(1,1,3, [0,0,0,100]); ellipseMode(CENTER); strokeWeight(1); stroke(COIN_OUTLINE_COLOR); fill(COIN_COLOR); ellipse(coinIconX, coinIconY, COIN_ICON_RADIUS * 2); clearShadow(); noStroke(); textAlign(RIGHT, TOP); applyShadow(1,1,2,HUD_TEXT_SHADOW_COLOR); fill(MENU_COIN_TEXT_COLOR); textSize(SCORE_TEXT_SIZE); text(liveCoinValue, coinTextX, coinDisplayY); clearShadow(); pop();

                    textAlign(CENTER, BOTTOM); textSize(INDICATOR_TEXT_SIZE); let indicatorY = height - 12; let indicatorRightX = width - 12;
                    applyShadow(1,1,2,HUD_TEXT_SHADOW_COLOR);
                    if (homing_shot_ready) { fill(INDICATOR_TEXT_COLOR); text("Homing Ready!", width / 2, indicatorY); }
                    if (time_stop_active) { let remaining_stop_time = (time_stop_end_time_ms - current_time_ms) / 1000; fill(0, 200, 255); textAlign(LEFT, BOTTOM); text(`Stop Active: ${max(0, remaining_stop_time).toFixed(1)}s`, 10, indicatorY); } else if (time_stop_ready) { fill(INDICATOR_TEXT_COLOR); textAlign(LEFT, BOTTOM); text("Stop Ready! (E)", 10, indicatorY); }
                    if (auto_fire_purchased) { textAlign(RIGHT, BOTTOM); if (auto_fire_active) { fill(0, 255, 0); text("Auto ON (Q)", indicatorRightX, indicatorY); } else { fill(255, 165, 0); text("Auto OFF (Q)", indicatorRightX, indicatorY); } }
                    clearShadow();
                    break;

                case STATE_CONFIRM_RESET:
                    background(MENU_BG_COLOR[0], MENU_BG_COLOR[1], MENU_BG_COLOR[2], 180);
                    let boxW = 320; let boxH = 170; let boxX = width / 2 - boxW / 2; let boxY = height / 2 - boxH / 2;
                    applyShadow(panelDropShadow.offsetX, panelDropShadow.offsetY, panelDropShadow.blurRadius, panelDropShadow.color);
                    fill(CONFIRM_BOX_COLOR); stroke(MENU_BG_COLOR); strokeWeight(2); rect(boxX, boxY, boxW, boxH, BUTTON_CORNER_RADIUS + 2);
                    clearShadow();
                    noStroke(); fill(CONFIRM_TEXT_COLOR); textAlign(CENTER, CENTER); textSize(18);
                    text("Reset all saved data?\nThis cannot be undone.", width / 2, boxY + boxH * 0.35);
                    let buttonY = boxY + boxH * 0.75 - CONFIRM_BUTTON_HEIGHT / 2;
                    confirmYesButton.x = boxX + boxW * 0.28 - CONFIRM_BUTTON_WIDTH / 2; confirmYesButton.y = buttonY;
                    confirmNoButton.x = boxX + boxW * 0.72 - CONFIRM_BUTTON_WIDTH / 2; confirmNoButton.y = buttonY;
                    drawStyledButton(confirmYesButton.x, confirmYesButton.y, confirmYesButton.w, confirmYesButton.h, "Yes", { baseColor: CONFIRM_YES_COLOR, hoverColor: CONFIRM_YES_HOVER, inactiveColor: CONFIRM_YES_COLOR, textColor: BUTTON_TEXT_COLOR, isHovered: confirmYesButton.isHovered, isActive: true, cornerRadius: BUTTON_CORNER_RADIUS, shadowOptions: defaultButtonShadow, textOptions: {size: 16} });
                    drawStyledButton(confirmNoButton.x, confirmNoButton.y, confirmNoButton.w, confirmNoButton.h, "No", { baseColor: CONFIRM_NO_COLOR, hoverColor: CONFIRM_NO_HOVER, inactiveColor: CONFIRM_NO_COLOR, textColor: BUTTON_TEXT_COLOR, isHovered: confirmNoButton.isHovered, isActive: true, cornerRadius: BUTTON_CORNER_RADIUS, shadowOptions: defaultButtonShadow, textOptions: {size: 16} });
                    break;
            }

            if (is_admin && admin_panel_open) {
                applyShadow(panelDropShadow.offsetX, panelDropShadow.offsetY, panelDropShadow.blurRadius, panelDropShadow.color);
                fill(ADMIN_PANEL_BG_COLOR); rect(0, 0, width, height);
                clearShadow();
                fill(ADMIN_PANEL_TEXT_COLOR); textAlign(CENTER, TOP); textSize(26);
                applyShadow(1,1,2,TITLE_SHADOW_COLOR); text("--- ADMIN PANEL ---", width / 2, 30); clearShadow();
                textAlign(LEFT, TOP); textSize(16); let panelY = ADMIN_PANEL_Y_START; let labelX = ADMIN_PANEL_X_MARGIN; let valueX = labelX + ADMIN_PANEL_VALUE_X_OFFSET;
                function drawAdminItem(y, keyDesc, currentValue) { text(keyDesc, labelX, y); text(currentValue, valueX, y); return y + ADMIN_PANEL_LINE_HEIGHT; }
                panelY = drawAdminItem(panelY, "[2/S+2] Speed:", `${speed_level} (Val: ${calculate_player_speed().toFixed(2)})`);
                panelY = drawAdminItem(panelY, "[3] Toggle Auto-Fire:", `${auto_fire_purchased}`);
                panelY = drawAdminItem(panelY, "[4] Add 1k Coins:", `${total_coins}`);
                panelY = drawAdminItem(panelY, "[5/S+5] Lives:", `${player_lives}`);
                panelY = drawAdminItem(panelY, "[6] Toggle Bouncy Gun:", `${bouncyGunPurchased}`);
                panelY = drawAdminItem(panelY, "[7] Toggle Shotgun:", `${shotgunPurchased}`);
                panelY = drawAdminItem(panelY, "[8] Toggle Machine Gun:", `${machineGunPurchased}`);
                textAlign(CENTER, BOTTOM); textSize(14); text("Modify Keys: # / Shift+#. [P] Close.", width / 2, height - 30);
            }

        }

        function mouseWheel(event) {
            if (current_state === STATE_SHOP) {
                shopScrollY += event.deltaY * 0.5;
                shopScrollY = constrain(shopScrollY, 0, shopScrollableHeight);
                return false;
            }
        }

    </script>
</body>
</html>
