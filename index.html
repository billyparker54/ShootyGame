<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>p5.js Game - Shooty Game (Waves)</title>
    <style>
        body { padding: 0; margin: 0; display: flex; justify-content: center; align-items: center; flex-direction: column; background-color: #f0f0f0; font-family: sans-serif;}
        canvas { margin-top: 20px; border: 1px solid #ccc; }
        h1 { margin-bottom: 5px;}
        .menu-button { /* Basic styling */ }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    </head>
<body>
    <h1>Shooty Game</h1>
    <script>
        // --- Constants ---
        const BASE_PLAYER_SPEED = 3.5; const BASE_BULLET_DAMAGE = 1; const BULLET_SPEED = 5;
        const SHOOT_COOLDOWN_MS = 300; const PLAYER_RADIUS = 15; const BULLET_RADIUS = 4;
        const BASE_ENEMY_RADIUS = 10; const BASE_ENEMY_HP = 1; const BASE_ENEMY_SPEED = 1.5;
        const BASE_ENEMY_SPAWN_RATE = 90; const ENEMY_COLOR = [200, 0, 50]; const BASE_ENEMY_REWARD = 1;
        const BLUE_ENEMY_RADIUS = 12; const BASE_BLUE_ENEMY_HP = 3; const BASE_BLUE_ENEMY_SPEED = BASE_ENEMY_SPEED * 1.5;
        const BASE_BLUE_ENEMY_SPAWN_INTERVAL_SEC = 12; const BLUE_ENEMY_COLOR = [0, 100, 255]; const BASE_BLUE_ENEMY_REWARD = 5;
        const POWERUP_COLOR = [128, 0, 128]; const POWERUP_WIDTH = 15; const POWERUP_HEIGHT = 15;
        const POWERUP_SPAWN_INTERVAL_SEC = 7; const POWERUP_TYPE_HOMING = "homing";
        const MAX_STEER_FORCE = 0.4; const TIME_STOP_DURATION_SEC = 2.0; const TIME_STOP_CHANCE = 0.05;
        const TIME_STOP_CHECK_INTERVAL_MS = 1000; const TIME_STOP_KEY = 'e'; const AUTO_FIRE_TOGGLE_KEY = 'q';
        const ADMIN_CHEAT_CODE = "sigma"; const ADMIN_PANEL_TOGGLE_KEY = 'p'; const WAVE_DURATION_SEC = 30;

        // Upgrade Costs
        const BASE_STRENGTH_COST = 20; const COST_INCREASE_STRENGTH = 15; const BASE_SPEED_COST = 15;
        const COST_INCREASE_SPEED = 10; const AUTO_FIRE_COST = 100;

        // Style Constants
        const PLAYER_COLOR = [0, 150, 255]; const BRONZE_COLOR = [205, 127, 50]; const BACKGROUND_COLOR = [220, 220, 220];
        const LASER_SIGHT_COLOR = [255, 0, 0]; const BRONZE_HIGHLIGHT_COLOR = [255, 224, 150];
        const BULLET_OUTLINE_COLOR = [0, 0, 0]; const BULLET_OUTLINE_WEIGHT = 1; const LASER_SIGHT_WEIGHT = 1.5;
        const COIN_COLOR = [255, 215, 0]; const COIN_OUTLINE_COLOR = [184, 134, 11]; const COIN_ICON_RADIUS = 9;
        const SCORE_TEXT_COLOR = [0, 0, 0]; const SCORE_TEXT_SIZE = 18; const INDICATOR_TEXT_COLOR = [255, 255, 255];
        const INDICATOR_TEXT_SIZE = 16; const SHOP_BG_COLOR = [50, 50, 70, 230]; const SHOP_TEXT_COLOR = [255, 255, 255];
        const GRAY_TEXT_COLOR = [150, 150, 150]; const MENU_BG_COLOR = [60, 60, 80]; const MENU_TEXT_COLOR = [255, 255, 255];
        const BUTTON_COLOR = [0, 150, 200]; const BUTTON_HOVER_COLOR = [0, 180, 240]; const BUTTON_TEXT_COLOR = [255, 255, 255];
        const ADMIN_INDICATOR_COLOR = [255, 100, 255]; const ADMIN_PANEL_BG_COLOR = [80, 60, 100, 240];
        const ADMIN_PANEL_TEXT_COLOR = [255, 255, 255];

        // Game State Constants
        const STATE_MENU = 0; const STATE_PLAYING = 1; const STATE_GAME_OVER = 2; const STATE_SHOP = 3;

        // --- Global Variables ---
        let player = null; let bullets = []; let enemies = []; let powerups = []; let spawn_timer = 0;
        let keys_pressed = new Set(); let current_state = STATE_MENU; let auto_aim_target = null;
        let strength_level = parseInt(localStorage.getItem('shootyGameStrengthLevel') || '0', 10);
        let speed_level = parseInt(localStorage.getItem('shootyGameSpeedLevel') || '0', 10);
        let total_coins = parseInt(localStorage.getItem('shootyGameTotalCoins') || '0', 10);
        let auto_fire_purchased = localStorage.getItem('shootyGameAutoFirePurchased') === 'true';
        let auto_fire_active = auto_fire_purchased;
        let current_wave = 0; let wave_timer_start_ms = 0; let wave_completed_flag = false;
        let current_enemy_spawn_rate = BASE_ENEMY_SPAWN_RATE; let current_blue_spawn_interval_sec = BASE_BLUE_ENEMY_SPAWN_INTERVAL_SEC;
        let current_run_score = 0; let current_player_speed; let current_bullet_damage; // Initialized after helpers defined
        let last_blue_spawn_time_ms = 0; let last_shot_time_ms = 0; let last_powerup_spawn_time_ms = 0;
        let homing_shot_ready = false; let time_stop_ready = false; let time_stop_active = false;
        let time_stop_end_time_ms = 0; let last_timestop_chance_check_time_ms = 0;
        let playButton = { x: 0, y: 0, w: 150, h: 50, isHovered: false };
        let shopButtonMenu = { x: 0, y: 0, w: 150, h: 50, isHovered: false };
        let resetButton = { x: 0, y: 0, w: 150, h: 40, isHovered: false };
        let is_admin = false; let cheat_input_buffer = ""; let admin_panel_open = false;

        // --- Helper Functions ---
        function calculate_player_speed() { return BASE_PLAYER_SPEED * (1.0 + speed_level * 0.20); }
        function calculate_bullet_damage() { return BASE_BULLET_DAMAGE + strength_level; }
        function get_strength_cost() { return BASE_STRENGTH_COST + strength_level * COST_INCREASE_STRENGTH; }
        function get_speed_cost() { return BASE_SPEED_COST + speed_level * COST_INCREASE_SPEED; }

        // Initialize calculated globals *after* helpers are defined
        current_player_speed = calculate_player_speed();
        current_bullet_damage = calculate_bullet_damage();

        function reset_saved_data() {
             let confirmed = confirm("Are you sure you want to reset all saved data?\nThis cannot be undone.");
             if (confirmed) {
                 console.log("Resetting saved data...");
                 localStorage.removeItem('shootyGameTotalCoins'); localStorage.removeItem('shootyGameStrengthLevel');
                 localStorage.removeItem('shootyGameSpeedLevel'); localStorage.removeItem('shootyGameAutoFirePurchased');
                 total_coins = 0; strength_level = 0; speed_level = 0;
                 auto_fire_purchased = false; auto_fire_active = false;
                 is_admin = false; admin_panel_open = false;
                 cheat_input_buffer = "";
                 current_player_speed = calculate_player_speed(); current_bullet_damage = calculate_bullet_damage();
                 console.log("Data reset complete.");
             } else { console.log("Data reset cancelled."); }
        }

        function find_closest_enemy(playerX, playerY, enemy_list) {
             let closest_enemy = null; let min_dist_sq = Infinity;
             for (let enemy of enemy_list) {
                 if (!enemy || typeof enemy.x === 'undefined' || typeof enemy.y === 'undefined' || enemy.hp <= 0) continue;
                 let dx = enemy.x - playerX; let dy = enemy.y - playerY; let dist_sq = dx * dx + dy * dy;
                 if (dist_sq < min_dist_sq) { min_dist_sq = dist_sq; closest_enemy = enemy; }
             } return closest_enemy;
         }
        function find_enemy_closest_by_angle(startX, startY, direction_vx, direction_vy, enemy_list) {
             if (!enemy_list || enemy_list.length === 0) return null;
             let shot_angle = atan2(direction_vy, direction_vx); let best_target = null; let min_angle_diff = Infinity;
             for (let enemy of enemy_list) {
                 if (!enemy || typeof enemy.x === 'undefined' || typeof enemy.y === 'undefined') continue;
                 let enemy_dx = enemy.x - startX; let enemy_dy = enemy.y - startY; let enemy_angle = atan2(enemy_dy, enemy_dx);
                 let diff = shot_angle - enemy_angle; while (diff <= -PI) diff += TWO_PI; while (diff > PI) diff -= TWO_PI;
                 let angle_diff = abs(diff);
                 if (angle_diff < min_angle_diff) { min_angle_diff = angle_diff; best_target = enemy; }
             } return best_target;
         }

        // --- Classes ---
        class Player {
             constructor(x, y, radius, speed, col) { this.x = x; this.y = y; this.radius = radius; this.speed = speed; this.color = col; }
             update() { let e_spd = this.speed; if (keys_pressed.has('w')||keys_pressed.has(UP_ARROW)){this.y-=e_spd;} if(keys_pressed.has('s')||keys_pressed.has(DOWN_ARROW)){this.y+=e_spd;} if(keys_pressed.has('a')||keys_pressed.has(LEFT_ARROW)){this.x-=e_spd;} if(keys_pressed.has('d')||keys_pressed.has(RIGHT_ARROW)){this.x+=e_spd;} this.x=constrain(this.x,this.radius,width-this.radius); this.y=constrain(this.y,this.radius,height-this.radius); }
             display() { fill(this.color[0], this.color[1], this.color[2]); noStroke(); ellipse(this.x, this.y, this.radius * 2); }
         }
        class Bullet {
            constructor(x, y, vx, vy, radius, col) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.radius = radius; this.color = col; }
            update() { this.x += this.vx; this.y += this.vy; }
            display() { stroke(BULLET_OUTLINE_COLOR[0],BULLET_OUTLINE_COLOR[1],BULLET_OUTLINE_COLOR[2]); strokeWeight(BULLET_OUTLINE_WEIGHT); fill(this.color[0],this.color[1],this.color[2]); ellipse(this.x,this.y,this.radius*2); noStroke(); fill(BRONZE_HIGHLIGHT_COLOR[0],BRONZE_HIGHLIGHT_COLOR[1],BRONZE_HIGHLIGHT_COLOR[2]); let hs=this.radius; let ho=this.radius*0.35; ellipse(this.x-ho,this.y-ho,hs,hs); }
            is_offscreen() { return !(this.x>-this.radius && this.x<width+this.radius && this.y>-this.radius && this.y<height+this.radius); }
        }
        class HomingBullet extends Bullet {
            constructor(x, y, vx, vy, radius, col, initial_target) { super(x, y, vx, vy, radius, col); this.target = initial_target; this.steer_force = MAX_STEER_FORCE; }
            update() { try { if (this.target && (typeof this.target.hp==='undefined' || this.target.hp<=0 || typeof this.target.x==='undefined' || typeof this.target.y==='undefined')) {this.target=null;} if (this.target) { let ddx=this.target.x-this.x; let ddy=this.target.y-this.y; let dist=sqrt(ddx*ddx+ddy*ddy); if (dist>0) { ddx/=dist; ddy/=dist; let dvx=ddx*BULLET_SPEED; let dvy=ddy*BULLET_SPEED; let svx=dvx-this.vx; let svy=dvy-this.vy; let sms=svx*svx+svy*svy; if(sms > this.steer_force*this.steer_force && sms > 0){ let sc=this.steer_force/sqrt(sms); svx*=sc; svy*=sc; } this.vx+=svx; this.vy+=svy; let css=this.vx*this.vx+this.vy*this.vy; if(css>BULLET_SPEED*BULLET_SPEED && css>0){ let sc=BULLET_SPEED/sqrt(css); this.vx*=sc; this.vy*=sc;}}} super.update();} catch(e){console.error("HomingBullet Error:", e); this.target=null; super.update();} }
         }
        class Enemy {
             constructor(x, y, radius, speed, hp, col, reward) { this.x=x; this.y=y; this.radius=radius; this.speed=speed; this.hp=hp; this.color=col; this.reward=reward; this.max_hp=hp; }
             update(target_x, target_y) { if(typeof target_x!=='number' || typeof target_y!=='number') return; let dx=target_x-this.x; let dy=target_y-this.y; let dist=sqrt(dx*dx+dy*dy); if (dist>0){let vx=(dx/dist)*this.speed; let vy=(dy/dist)*this.speed; this.x+=vx; this.y+=vy;}}
             display() { fill(this.color[0], this.color[1], this.color[2]); noStroke(); ellipse(this.x, this.y, this.radius * 2); }
             take_damage(damage_amount) { this.hp -= damage_amount; return this.hp <= 0; }
         }
        class PowerUp {
              constructor(x, y, w, h, color, type) { this.x=x; this.y=y; this.width=w; this.height=h; this.color=color; this.type=type; }
              display() { fill(this.color[0], this.color[1], this.color[2]); noStroke(); rect(this.x, this.y, this.width, this.height); }
          }

        // --- Spawning / Collision Helpers ---
        function spawn_enemy() {
             let edge=floor(random(4)); let sx=0, sy=0; let m=BASE_ENEMY_RADIUS+10; if(edge===0){sx=random(width); sy=-m;} else if(edge===1){sx=random(width); sy=height+m;} else if(edge===2){sx=-m; sy=random(height);} else {sx=width+m; sy=random(height);} let rwd=BASE_ENEMY_REWARD+floor(current_wave/5); let ne=new Enemy(sx,sy,BASE_ENEMY_RADIUS,BASE_ENEMY_SPEED,BASE_ENEMY_HP,ENEMY_COLOR,rwd); enemies.push(ne);
         }
        function spawn_blue_enemy() {
             let edge=floor(random(4)); let sx=0, sy=0; let m=BLUE_ENEMY_RADIUS+10; if(edge===0){sx=random(width); sy=-m;} else if(edge===1){sx=random(width); sy=height+m;} else if(edge===2){sx=-m; sy=random(height);} else {sx=width+m; sy=random(height);} let rwd=BASE_BLUE_ENEMY_REWARD+floor(current_wave/3); let ne=new Enemy(sx,sy,BLUE_ENEMY_RADIUS,BASE_BLUE_ENEMY_SPEED,BASE_BLUE_ENEMY_HP,BLUE_ENEMY_COLOR,rwd); enemies.push(ne);
         }
        function spawn_powerup() {
              if(powerups.length===0){ let px=random(width-POWERUP_WIDTH); let py=random(height-POWERUP_HEIGHT); let np=new PowerUp(px,py,POWERUP_WIDTH,POWERUP_HEIGHT,POWERUP_COLOR,POWERUP_TYPE_HOMING); powerups.push(np);}
         }
        function check_player_powerup_collision(p_obj, pu_list) {
              if (!p_obj) return; for(let i=pu_list.length-1; i>=0; i--){ if(!pu_list[i]) continue; let pu=pu_list[i]; let cx=constrain(p_obj.x,pu.x,pu.x+pu.width); let cy=constrain(p_obj.y,pu.y,pu.y+pu.height); let dSq=(p_obj.x-cx)**2+(p_obj.y-cy)**2; if(dSq < p_obj.radius**2){ if(pu.type===POWERUP_TYPE_HOMING){homing_shot_ready=true;} pu_list.splice(i,1); break;}}
         }

        // --- Game/Wave Start Function ---
        function start_new_game_or_wave(wave_number) {
            console.log(`Starting Wave ${wave_number}...`); current_wave = wave_number;
            current_enemy_spawn_rate = max(20, BASE_ENEMY_SPAWN_RATE - (current_wave - 1) * 4);
            current_blue_spawn_interval_sec = max(4, BASE_BLUE_ENEMY_SPAWN_INTERVAL_SEC - floor((current_wave - 1) / 2));
            console.log(`Wave ${current_wave} Diff: Rate=${current_enemy_spawn_rate}, BlueInt=${current_blue_spawn_interval_sec}s`);
            current_player_speed = calculate_player_speed(); current_bullet_damage = calculate_bullet_damage(); auto_fire_active = auto_fire_purchased;
            let px=width/2; let py=height/2; player = new Player(px,py,PLAYER_RADIUS,current_player_speed,PLAYER_COLOR);
            bullets=[]; enemies=[]; powerups=[]; keys_pressed=new Set(); spawn_timer=0; auto_aim_target=null;
            wave_timer_start_ms=millis(); last_blue_spawn_time_ms=wave_timer_start_ms; last_powerup_spawn_time_ms=wave_timer_start_ms;
            homing_shot_ready=false; time_stop_ready=false; time_stop_active=false; time_stop_end_time_ms=0; last_timestop_chance_check_time_ms=wave_timer_start_ms; wave_completed_flag=false;
            if(wave_number===1){current_run_score=0;}
            current_state=STATE_PLAYING; console.log("Game reset. AF active:", auto_fire_active);
         }

        // --- p5.js Event Handlers ---
        function keyPressed() {
            let keyLower = key.toLowerCase();

            if (is_admin && admin_panel_open) { let sc=false; if(key==='1'){if(keyIsDown(SHIFT)){if(strength_level>0)strength_level--; sc=true;}else{strength_level++; sc=true;}}else if(key==='2'){if(keyIsDown(SHIFT)){if(speed_level>0)speed_level--; sc=true;}else{speed_level++; sc=true;}}else if(key==='3'){auto_fire_purchased=!auto_fire_purchased; auto_fire_active=auto_fire_purchased; sc=true;}else if(key==='4'){total_coins+=1000; sc=true;}else if(keyLower===ADMIN_PANEL_TOGGLE_KEY){admin_panel_open=false; console.log("ADMIN PANEL: Closed"); return false;} if(sc){current_player_speed=calculate_player_speed(); current_bullet_damage=calculate_bullet_damage(); localStorage.setItem('shootyGameStrengthLevel',strength_level.toString()); localStorage.setItem('shootyGameSpeedLevel',speed_level.toString()); localStorage.setItem('shootyGameTotalCoins',total_coins.toString()); localStorage.setItem('shootyGameAutoFirePurchased',auto_fire_purchased?'true':'false'); console.log(`ADMIN Change - Str:${strength_level}, Spd:${speed_level}, Coins:${total_coins}, AutoFire:${auto_fire_purchased}`);} return false; }
            if (keyLower===ADMIN_PANEL_TOGGLE_KEY && is_admin) { admin_panel_open=!admin_panel_open; console.log("ADMIN PANEL:", admin_panel_open?"Opened":"Closed"); if(admin_panel_open) auto_aim_target=null; return false; }
            if (current_state===STATE_MENU && !is_admin) { if(keyLower.length===1 && keyLower>='a' && keyLower<='z'){ cheat_input_buffer+=keyLower; if(cheat_input_buffer.length>ADMIN_CHEAT_CODE.length){cheat_input_buffer=cheat_input_buffer.substring(cheat_input_buffer.length-ADMIN_CHEAT_CODE.length);} if(cheat_input_buffer===ADMIN_CHEAT_CODE){is_admin=true; console.log("ADMIN MODE ACTIVATED!"); cheat_input_buffer="";}} }

            switch(current_state){
                 case STATE_MENU: break;
                 case STATE_SHOP: if(key==='1'){let c=get_strength_cost(); if(total_coins>=c){total_coins-=c; strength_level++; localStorage.setItem('shootyGameTotalCoins',total_coins.toString()); localStorage.setItem('shootyGameStrengthLevel',strength_level.toString()); current_bullet_damage=calculate_bullet_damage();}} else if(key==='2'){let c=get_speed_cost(); if(total_coins>=c){total_coins-=c; speed_level++; localStorage.setItem('shootyGameTotalCoins',total_coins.toString()); localStorage.setItem('shootyGameSpeedLevel',speed_level.toString()); current_player_speed=calculate_player_speed();}} else if(key==='3'){if(!auto_fire_purchased){if(total_coins>=AUTO_FIRE_COST){total_coins-=AUTO_FIRE_COST; auto_fire_purchased=true; auto_fire_active=true; localStorage.setItem('shootyGameTotalCoins',total_coins.toString()); localStorage.setItem('shootyGameAutoFirePurchased','true');}}} else if(keyLower==='n'&&wave_completed_flag){start_new_game_or_wave(current_wave+1); return false;} else if(keyLower==='m'){current_state=STATE_MENU; wave_completed_flag=false; return false;} if("123nm".includes(keyLower)) return false; break;
                 case STATE_GAME_OVER: if(key===' '){start_new_game_or_wave(1); return false;} else if(keyLower==='u'){current_state=STATE_SHOP; wave_completed_flag=false; return false;} else if(keyLower==='m'){current_state=STATE_MENU; wave_completed_flag=false; return false;} if(" um".includes(keyLower)||key==' ') return false; break;
                 case STATE_PLAYING: if(admin_panel_open) return false; if(keyLower===TIME_STOP_KEY&&time_stop_ready&&!time_stop_active){time_stop_ready=false; time_stop_active=true; time_stop_end_time_ms=millis()+TIME_STOP_DURATION_SEC*1000; console.log("TIME STOP ACTIVATED!"); return false;} else if(keyLower===AUTO_FIRE_TOGGLE_KEY&&auto_fire_purchased){auto_fire_active=!auto_fire_active; console.log("Auto-Fire Toggled. Active:", auto_fire_active); auto_aim_target=null; return false;} if(keyCode===UP_ARROW||keyCode===DOWN_ARROW||keyCode===LEFT_ARROW||keyCode===RIGHT_ARROW){keys_pressed.add(keyCode);}else{keys_pressed.add(keyLower);} if(key===' '||keyLower===TIME_STOP_KEY||keyLower===AUTO_FIRE_TOGGLE_KEY||keyCode===UP_ARROW||keyCode===DOWN_ARROW||keyCode===LEFT_ARROW||keyCode===RIGHT_ARROW){return false;} break;
             }
         }
        function keyReleased() {
             if(current_state===STATE_PLAYING){let kl=key.toLowerCase(); if(keyCode===UP_ARROW||keyCode===DOWN_ARROW||keyCode===LEFT_ARROW||keyCode===RIGHT_ARROW){keys_pressed.delete(keyCode);}else{keys_pressed.delete(kl);}}
         }
        function mousePressed() {
             switch(current_state){
                 case STATE_PLAYING: if(!auto_fire_active && player && !admin_panel_open){let ctm=millis(); if(ctm-last_shot_time_ms>=SHOOT_COOLDOWN_MS){let dx=mouseX-player.x; let dy=mouseY-player.y; let dist=sqrt(dx*dx+dy*dy); if(dist>0){let vx=(dx/dist)*BULLET_SPEED; let vy=(dy/dist)*BULLET_SPEED; let nb; if(homing_shot_ready){let te=find_enemy_closest_by_angle(player.x,player.y,vx,vy,enemies); nb=new HomingBullet(player.x,player.y,vx,vy,BULLET_RADIUS,BRONZE_COLOR,te); homing_shot_ready=false;}else{nb=new Bullet(player.x,player.y,vx,vy,BULLET_RADIUS,BRONZE_COLOR);} bullets.push(nb); last_shot_time_ms=ctm;}}} break;
                 case STATE_MENU: if(!admin_panel_open){if(playButton.isHovered){start_new_game_or_wave(1);}else if(shopButtonMenu.isHovered){current_state=STATE_SHOP; wave_completed_flag=false;}else if(resetButton.isHovered){reset_saved_data();}} break;
                 case STATE_SHOP: break; case STATE_GAME_OVER: break;
             }
         }

        // --- p5.js Setup Function ---
        function setup() {
            createCanvas(600, 400);
            playButton.x = width/2-playButton.w/2; playButton.y = height/2-playButton.h/2-30; shopButtonMenu.x = width/2-shopButtonMenu.w/2; shopButtonMenu.y=playButton.y+playButton.h+10; resetButton.x = width/2-resetButton.w/2; resetButton.y=shopButtonMenu.y+shopButtonMenu.h+15;
            current_state = STATE_MENU; is_admin = false; admin_panel_open = false; cheat_input_buffer = "";
            console.log("p5.js Game Setup Complete.");
         }

        // --- p5.js Draw Function ---
        function draw() {
            let current_time_ms = millis();

             if (current_state === STATE_MENU) { // Update Button Hover States only if panel closed
                 playButton.isHovered = !admin_panel_open && (mouseX > playButton.x && mouseX < playButton.x + playButton.w && mouseY > playButton.y && mouseY < playButton.y + playButton.h);
                 shopButtonMenu.isHovered = !admin_panel_open && (mouseX > shopButtonMenu.x && mouseX < shopButtonMenu.x + shopButtonMenu.w && mouseY > shopButtonMenu.y && mouseY < shopButtonMenu.y + shopButtonMenu.h);
                 resetButton.isHovered = !admin_panel_open && (mouseX > resetButton.x && mouseX < resetButton.x + resetButton.w && mouseY > resetButton.y && mouseY < resetButton.y + resetButton.h);
             }

            // --- Draw Normal Game State ---
            switch (current_state) {
                case STATE_MENU:
                     background(MENU_BG_COLOR); textAlign(CENTER, CENTER); fill(MENU_TEXT_COLOR); textSize(48); text("Shooty Game", width / 2, height * 0.28); textSize(18); text("Total Coins: " + total_coins, width / 2, height * 0.28 + 60); fill(playButton.isHovered ? BUTTON_HOVER_COLOR : BUTTON_COLOR); noStroke(); rect(playButton.x, playButton.y, playButton.w, playButton.h, 5); fill(BUTTON_TEXT_COLOR); textSize(24); text("Play", playButton.x + playButton.w / 2, playButton.y + playButton.h / 2); fill(shopButtonMenu.isHovered ? BUTTON_HOVER_COLOR : BUTTON_COLOR); noStroke(); rect(shopButtonMenu.x, shopButtonMenu.y, shopButtonMenu.w, shopButtonMenu.h, 5); fill(BUTTON_TEXT_COLOR); textSize(24); text("Shop", shopButtonMenu.x + shopButtonMenu.w / 2, shopButtonMenu.y + shopButtonMenu.h / 2); let rbc = [180, 50, 50]; let rhc = [220, 80, 80]; fill(resetButton.isHovered ? rhc : rbc); noStroke(); rect(resetButton.x, resetButton.y, resetButton.w, resetButton.h, 5); fill(BUTTON_TEXT_COLOR); textSize(18); text("Reset Data", resetButton.x + resetButton.w / 2, resetButton.y + resetButton.h / 2); if (is_admin) { fill(ADMIN_INDICATOR_COLOR); textSize(14); textAlign(CENTER, BOTTOM); text("ADMIN MODE ACTIVE (P to open panel)", width / 2, height - 10); }
                     break;
                case STATE_SHOP:
                     fill(SHOP_BG_COLOR); rect(0, 0, width, height); fill(SHOP_TEXT_COLOR); textSize(24); textAlign(CENTER, TOP); if (wave_completed_flag) { text(`Wave ${current_wave} Complete!`, width/2, 30); } else { text("SHOP", width/2, 30); } textSize(18); text("Total Coins: " + total_coins, width/2, 60); let instructionY=height-30; textSize(14); textAlign(CENTER, BOTTOM); if(wave_completed_flag){text("Press Number to Buy/Upgrade. Press [N] for Next Wave / [M] for Main Menu.",width/2,instructionY);}else{text("Press Number to Buy/Upgrade. Press [M] for Main Menu.",width/2,instructionY);} textAlign(LEFT, TOP); textSize(16); let shopY = 100; let str_cost=get_strength_cost(); let str_dmg=calculate_bullet_damage(); fill(SHOP_TEXT_COLOR); text(`[1] Str Lvl: ${strength_level} (Dmg: ${str_dmg})`,50,shopY); shopY+=25; text(`    Cost: ${str_cost}`,50,shopY); if(total_coins<str_cost){fill(GRAY_TEXT_COLOR); text(" (Not Enough)",50+textWidth(` Cost: ${str_cost}`)+5,shopY);} shopY+=35; let spd_cost=get_speed_cost(); let spv=calculate_player_speed(); let spp=speed_level*20; fill(SHOP_TEXT_COLOR); text(`[2] Spd Lvl: ${speed_level} (+${spp}%, Val: ${spv.toFixed(2)})`,50,shopY); shopY+=25; text(`    Cost: ${spd_cost}`,50,shopY); if(total_coins<spd_cost){fill(GRAY_TEXT_COLOR); text(" (Not Enough)",50+textWidth(` Cost: ${spd_cost}`)+5,shopY);} shopY+=35; fill(SHOP_TEXT_COLOR); textSize(18); text("--- Weapons ---",50,shopY); shopY+=30; textSize(16); if(auto_fire_purchased){fill(GRAY_TEXT_COLOR); text("[3] Auto-Fire Gun: Purchased",50,shopY); shopY+=25; fill(SHOP_TEXT_COLOR); text("    (Press Q in game to toggle)",50,shopY);}else{fill(SHOP_TEXT_COLOR); text("[3] Auto-Fire Gun",50,shopY); shopY+=25; text(`    Cost: ${AUTO_FIRE_COST}`,50,shopY); if(total_coins<AUTO_FIRE_COST){fill(GRAY_TEXT_COLOR); text(" (Not Enough)",50+textWidth(` Cost: ${AUTO_FIRE_COST}`)+5,shopY);}}
                     break;
                case STATE_GAME_OVER:
                      background(100); fill(255,0,0); textSize(32); textAlign(CENTER,CENTER); text("GAME OVER",width/2,height/2-40); fill(255); textSize(16); text(`Reached Wave: ${current_wave}`,width/2,height/2-5); text("Total Coins: "+total_coins,width/2,height/2+20); text("Score This Run: "+current_run_score,width/2,height/2+45); text("Press [SPACE] to Restart (Wave 1)",width/2,height/2+105); text("Press [U] for Shop",width/2,height/2+130); text("Press [M] for Main Menu",width/2,height/2+155);
                      break;
                case STATE_PLAYING:
                    background(BACKGROUND_COLOR);
                    if(player){player.update(); check_player_powerup_collision(player,powerups);}
                    if(time_stop_active && current_time_ms>=time_stop_end_time_ms){time_stop_active=false;}
                    if(auto_fire_active && player){auto_aim_target=find_closest_enemy(player.x,player.y,enemies);}else{auto_aim_target=null;}

                    if(!time_stop_active && !admin_panel_open){
                        let ewt=(current_time_ms-wave_timer_start_ms)/1000.0;
                        if(ewt>=WAVE_DURATION_SEC){console.log(`Wave ${current_wave} ended.`); wave_completed_flag=true; bullets=[]; powerups=[]; homing_shot_ready=false; current_state=STATE_SHOP; return;} // Exit draw on wave end
                        else {
                            if(current_time_ms-last_timestop_chance_check_time_ms>=TIME_STOP_CHECK_INTERVAL_MS){if(!time_stop_ready&&!time_stop_active){if(random()<TIME_STOP_CHANCE){time_stop_ready=true;}} last_timestop_chance_check_time_ms+=TIME_STOP_CHECK_INTERVAL_MS;}
                            for(let i=bullets.length-1;i>=0;i--){if(bullets[i]){bullets[i].update(); if(bullets[i].is_offscreen()){bullets.splice(i,1);}}else{bullets.splice(i,1);}}
                            for(let i=enemies.length-1;i>=0;i--){if(enemies[i]){if(player){enemies[i].update(player.x,player.y);}}else{enemies.splice(i,1);}}
                            spawn_timer++; if(spawn_timer>=current_enemy_spawn_rate){spawn_enemy(); spawn_timer=0;}
                            if(current_time_ms-last_blue_spawn_time_ms>=current_blue_spawn_interval_sec*1000){spawn_blue_enemy(); last_blue_spawn_time_ms=current_time_ms;}
                            if(current_time_ms-last_powerup_spawn_time_ms>=POWERUP_SPAWN_INTERVAL_SEC*1000){spawn_powerup(); last_powerup_spawn_time_ms=current_time_ms;}
                            if(auto_fire_active&&player&&auto_aim_target){let afdx=auto_aim_target.x-player.x; let afdy=auto_aim_target.y-player.y; let afd=sqrt(afdx*afdx+afdy*afdy); if(afd>0 && current_time_ms-last_shot_time_ms>=SHOOT_COOLDOWN_MS){let vx=(afdx/afd)*BULLET_SPEED; let vy=(afdy/afd)*BULLET_SPEED; let nb; if(homing_shot_ready){nb=new HomingBullet(player.x,player.y,vx,vy,BULLET_RADIUS,BRONZE_COLOR,auto_aim_target); homing_shot_ready=false;}else{nb=new Bullet(player.x,player.y,vx,vy,BULLET_RADIUS,BRONZE_COLOR);} bullets.push(nb); last_shot_time_ms=current_time_ms;}}
                        }
                    } // End Time-Dependent Updates

                    let aim_dx=0, aim_dy=0, aim_dist=0;
                    if(player){if(auto_fire_active&&auto_aim_target){aim_dx=auto_aim_target.x-player.x; aim_dy=auto_aim_target.y-player.y;}else if(!auto_fire_active){aim_dx=mouseX-player.x; aim_dy=mouseY-player.y;} aim_dist=sqrt(aim_dx*aim_dx+aim_dy*aim_dy); if(aim_dist>0&&!admin_panel_open){let nx=aim_dx/aim_dist; let ny=aim_dy/aim_dist; let pl=max(width,height)*1.5; let ex=player.x+nx*pl; let ey=player.y+ny*pl; stroke(LASER_SIGHT_COLOR); strokeWeight(LASER_SIGHT_WEIGHT); line(player.x,player.y,ex,ey); noStroke();}}

                    for(let i=bullets.length-1; i>=0; i--){if(!bullets[i]) continue; let b=bullets[i]; let br=false; for(let j=enemies.length-1; j>=0; j--){if(!enemies[j]) continue; let e=enemies[j]; let dSq=(b.x-e.x)**2+(b.y-e.y)**2; let rSq=(b.radius+e.radius)**2; if(dSq<=rSq){if(e.take_damage(current_bullet_damage)){current_run_score+=e.reward; if(e===auto_aim_target){auto_aim_target=null;} enemies.splice(j,1);} if(!br){bullets.splice(i,1); br=true; break;}}}}
                    if(player){for(let j=enemies.length-1; j>=0; j--){if(!enemies[j]) continue; let e=enemies[j]; let dSq=(e.x-player.x)**2+(e.y-player.y)**2; let rSq=(e.radius+player.radius)**2; if(dSq<=rSq){console.log("GAME OVER!"); keys_pressed.clear(); player=null; auto_aim_target=null; total_coins+=current_run_score; localStorage.setItem('shootyGameTotalCoins',total_coins.toString()); current_state=STATE_GAME_OVER; break;}}}

                    if(player) player.display(); for(let b of bullets){if(b)b.display();} for(let p of powerups){if(p)p.display();} noStroke(); for(let e of enemies){if(e)e.display();}

                    fill(SCORE_TEXT_COLOR); textSize(SCORE_TEXT_SIZE); textAlign(LEFT,TOP); let tr=max(0,WAVE_DURATION_SEC-((millis()-wave_timer_start_ms)/1000.0)); text(`Wave: ${current_wave} | Time: ${tr.toFixed(1)}`,10,10); let sdy=10; let cir=COIN_ICON_RADIUS; let cix=width-15-cir; let ciy=sdy+cir/2+2; let stx=cix-cir-5; push(); ellipseMode(CENTER); strokeWeight(1); stroke(COIN_OUTLINE_COLOR); fill(COIN_COLOR); ellipse(cix,ciy,cir*2); pop(); noStroke(); fill(SCORE_TEXT_COLOR); textAlign(RIGHT,TOP); textSize(SCORE_TEXT_SIZE); text(current_run_score, stx, sdy);
                    textAlign(CENTER,BOTTOM); textSize(INDICATOR_TEXT_SIZE); let iy=height-10; let irx=width-10; if(homing_shot_ready){fill(INDICATOR_TEXT_COLOR); text("Homing Ready!",width/2,iy);} if(time_stop_active){let rem=(time_stop_end_time_ms-current_time_ms)/1000; fill(0,200,255); textAlign(LEFT,BOTTOM); text(`Stop Active: ${max(0,rem).toFixed(1)}s`,10,iy);} else if(time_stop_ready){fill(INDICATOR_TEXT_COLOR); textAlign(LEFT,BOTTOM); text("Stop Ready!(E)",10,iy);} if(auto_fire_purchased){textAlign(RIGHT,BOTTOM); if(auto_fire_active){fill(0,255,0); text("Auto ON (Q)",irx,iy);} else {fill(255,165,0); text("Auto OFF (Q)",irx,iy);}}
                    break; // End STATE_PLAYING
            } // End switch(current_state)

            // Draw Admin Panel (Overlay)
            if (is_admin && admin_panel_open) { fill(ADMIN_PANEL_BG_COLOR); rect(0,0,width,height); fill(ADMIN_PANEL_TEXT_COLOR); textAlign(CENTER,TOP); textSize(24); text("--- ADMIN PANEL ---",width/2,30); textAlign(LEFT,TOP); textSize(16); let py=80; text("Stats:",50,py); py+=25; text(`[1/S+1] Str: ${strength_level} (Dmg: ${calculate_bullet_damage()})`,60,py); py+=25; text(`[2/S+2] Spd: ${speed_level} (Val: ${calculate_player_speed().toFixed(2)})`,60,py); py+=25; text(`[4] +1k Coins (${total_coins})`,60,py); py+=25; text(`[3] Toggle Auto-Fire (${auto_fire_purchased})`,60,py); py+=40; textAlign(CENTER,BOTTOM); textSize(14); text("Modify Keys: # / Shift+#. [P] Close.",width/2,height-30); }

        } // End of draw function

    </script>
</body>
</html>